/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const HAL_kInvalidHandle: i32 = 0;
pub const HAL_CAN_SEND_PERIOD_NO_REPEAT: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_STOP_REPEATING: i32 = -1;
pub const HAL_CAN_IS_FRAME_REMOTE: u32 = 2147483648;
pub const HAL_CAN_IS_FRAME_11BIT: u32 = 1073741824;
pub const HAL_ERR_CANSessionMux_InvalidBuffer: i32 = -44086;
pub const HAL_ERR_CANSessionMux_MessageNotFound: i32 = -44087;
pub const HAL_WARN_CANSessionMux_NoToken: u32 = 44087;
pub const HAL_ERR_CANSessionMux_NotAllowed: i32 = -44088;
pub const HAL_ERR_CANSessionMux_NotInitialized: i32 = -44089;
pub const HAL_ERR_CANSessionMux_SessionOverrun: u32 = 44050;
pub const HAL_IO_CONFIG_DATA_SIZE: u32 = 32;
pub const HAL_SYS_STATUS_DATA_SIZE: u32 = 44;
pub const HAL_USER_STATUS_DATA_SIZE: u32 = 908;
pub const HAL_kMaxJoystickAxes: u32 = 12;
pub const HAL_kMaxJoystickPOVs: u32 = 12;
pub const HAL_kMaxJoysticks: u32 = 6;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL: i32 = -1035;
pub const HAL_COUNTER_NOT_SUPPORTED: i32 = -1058;
pub const HAL_PWM_SCALE_ERROR: i32 = -1072;
pub const HAL_HANDLE_ERROR: i32 = -1098;
pub const HAL_LED_CHANNEL_ERROR: i32 = -1099;
pub const HAL_INVALID_DMA_ADDITION: i32 = -1102;
pub const HAL_SERIAL_PORT_NOT_FOUND: i32 = -1123;
pub const HAL_SERIAL_PORT_OPEN_ERROR: i32 = -1124;
pub const HAL_SERIAL_PORT_ERROR: i32 = -1125;
pub const HAL_THREAD_PRIORITY_ERROR: i32 = -1152;
pub const HAL_THREAD_PRIORITY_RANGE_ERROR: i32 = -1153;
pub const HAL_CAN_TIMEOUT: i32 = -1154;
pub const HAL_SIM_NOT_SUPPORTED: i32 = -1155;
pub const HAL_CAN_BUFFER_OVERRUN: i32 = -35007;
pub type HAL_Handle = i32;
pub type HAL_PortHandle = HAL_Handle;
pub type HAL_AnalogInputHandle = HAL_Handle;
pub type HAL_AnalogOutputHandle = HAL_Handle;
pub type HAL_AnalogTriggerHandle = HAL_Handle;
pub type HAL_CompressorHandle = HAL_Handle;
pub type HAL_CounterHandle = HAL_Handle;
pub type HAL_DigitalHandle = HAL_Handle;
pub type HAL_DigitalPWMHandle = HAL_Handle;
pub type HAL_EncoderHandle = HAL_Handle;
pub type HAL_FPGAEncoderHandle = HAL_Handle;
pub type HAL_GyroHandle = HAL_Handle;
pub type HAL_InterruptHandle = HAL_Handle;
pub type HAL_NotifierHandle = HAL_Handle;
pub type HAL_RelayHandle = HAL_Handle;
pub type HAL_SolenoidHandle = HAL_Handle;
pub type HAL_SerialPortHandle = HAL_Handle;
pub type HAL_CANHandle = HAL_Handle;
pub type HAL_SimDeviceHandle = HAL_Handle;
pub type HAL_SimValueHandle = HAL_Handle;
pub type HAL_DMAHandle = HAL_Handle;
pub type HAL_DutyCycleHandle = HAL_Handle;
pub type HAL_AddressableLEDHandle = HAL_Handle;
pub type HAL_PDPHandle = HAL_CANHandle;
pub type HAL_Bool = i32;
pub mod HAL_AccelerometerRange {
    #[doc = " The acceptable accelerometer ranges."]
    pub type Type = i32;
    pub const k2G: Type = 0;
    pub const k4G: Type = 1;
    pub const k8G: Type = 2;
}
extern "C" {
    #[doc = " Sets the accelerometer to active or standby mode."]
    #[doc = ""]
    #[doc = " It must be in standby mode to change any configuration."]
    #[doc = ""]
    #[doc = " @param active true to set to active, false for standby"]
    pub fn HAL_SetAccelerometerActive(active: HAL_Bool);
}
extern "C" {
    #[doc = " Sets the range of values that can be measured (either 2, 4, or 8 g-forces)."]
    #[doc = ""]
    #[doc = " The accelerometer should be in standby mode when this is called."]
    #[doc = ""]
    #[doc = " @param range the accelerometer range"]
    pub fn HAL_SetAccelerometerRange(range: HAL_AccelerometerRange::Type);
}
extern "C" {
    #[doc = " Gets the x-axis acceleration."]
    #[doc = ""]
    #[doc = " This is a floating point value in units of 1 g-force."]
    #[doc = ""]
    #[doc = " @return the X acceleration"]
    pub fn HAL_GetAccelerometerX() -> f64;
}
extern "C" {
    #[doc = " Gets the y-axis acceleration."]
    #[doc = ""]
    #[doc = " This is a floating point value in units of 1 g-force."]
    #[doc = ""]
    #[doc = " @return the Y acceleration"]
    pub fn HAL_GetAccelerometerY() -> f64;
}
extern "C" {
    #[doc = " Gets the z-axis acceleration."]
    #[doc = ""]
    #[doc = " This is a floating point value in units of 1 g-force."]
    #[doc = ""]
    #[doc = " @return the Z acceleration"]
    pub fn HAL_GetAccelerometerZ() -> f64;
}
extern "C" {
    #[doc = " Is the channel attached to an accumulator."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    #[doc = " @return The analog channel is attached to an accumulator."]
    pub fn HAL_IsAccumulatorChannel(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Initialize the accumulator."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    pub fn HAL_InitAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Resets the accumulator to the initial value."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    pub fn HAL_ResetAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Set the center value of the accumulator."]
    #[doc = ""]
    #[doc = " The center value is subtracted from each A/D value before it is added to the"]
    #[doc = " accumulator. This is used for the center value of devices like gyros and"]
    #[doc = " accelerometers to make integration work and to take the device offset into"]
    #[doc = " account when integrating."]
    #[doc = ""]
    #[doc = " This center value is based on the output of the oversampled and averaged"]
    #[doc = " source from channel 1. Because of this, any non-zero oversample bits will"]
    #[doc = " affect the size of the value for this field."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    #[doc = " @param center The center value of the accumulator."]
    pub fn HAL_SetAccumulatorCenter(
        analogPortHandle: HAL_AnalogInputHandle,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Set the accumulator's deadband."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    #[doc = " @param deadband The deadband of the accumulator."]
    pub fn HAL_SetAccumulatorDeadband(
        analogPortHandle: HAL_AnalogInputHandle,
        deadband: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Read the accumulated value."]
    #[doc = ""]
    #[doc = " Read the value that has been accumulating on channel 1."]
    #[doc = " The accumulator is attached after the oversample and average engine."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    #[doc = " @return The 64-bit value accumulated since the last Reset()."]
    pub fn HAL_GetAccumulatorValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the number of accumulated values."]
    #[doc = ""]
    #[doc = " Read the count of the accumulated values since the accumulator was last"]
    #[doc = " Reset()."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    #[doc = " @return The number of times samples from the channel were accumulated."]
    pub fn HAL_GetAccumulatorCount(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the accumulated value and the number of accumulated values atomically."]
    #[doc = ""]
    #[doc = " This function reads the value and count from the FPGA atomically."]
    #[doc = " This can be used for averaging."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    #[doc = " @param value Pointer to the 64-bit accumulated output."]
    #[doc = " @param count Pointer to the number of accumulation cycles."]
    pub fn HAL_GetAccumulatorOutput(
        analogPortHandle: HAL_AnalogInputHandle,
        value: *mut i64,
        count: *mut i64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes an analog gyro."]
    #[doc = ""]
    #[doc = " @param handle handle to the analog port"]
    #[doc = " @return       the initialized gyro handle"]
    pub fn HAL_InitializeAnalogGyro(
        handle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_GyroHandle;
}
extern "C" {
    #[doc = " Sets up an analog gyro with the proper offsets and settings for the KOP"]
    #[doc = " analog gyro."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    pub fn HAL_SetupAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an analog gyro."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    pub fn HAL_FreeAnalogGyro(handle: HAL_GyroHandle);
}
extern "C" {
    #[doc = " Sets the analog gyro parameters to the specified values."]
    #[doc = ""]
    #[doc = " This is meant to be used if you want to reuse the values from a previous"]
    #[doc = " calibration."]
    #[doc = ""]
    #[doc = " @param handle                  the gyro handle"]
    #[doc = " @param voltsPerDegreePerSecond the gyro volts scaling"]
    #[doc = " @param offset                  the gyro offset"]
    #[doc = " @param center                  the gyro center"]
    pub fn HAL_SetAnalogGyroParameters(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        offset: f64,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the analog gyro volts per degrees per second scaling."]
    #[doc = ""]
    #[doc = " @param handle                  the gyro handle"]
    #[doc = " @param voltsPerDegreePerSecond the gyro volts scaling"]
    pub fn HAL_SetAnalogGyroVoltsPerDegreePerSecond(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the analog gyro value to 0."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    pub fn HAL_ResetAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Calibrates the analog gyro."]
    #[doc = ""]
    #[doc = " This happens by calculating the average value of the gyro over 5 seconds, and"]
    #[doc = " setting that as the center. Note that this call blocks for 5 seconds to"]
    #[doc = " perform this."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    pub fn HAL_CalibrateAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the deadband of the analog gyro."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    #[doc = " @param volts  the voltage deadband"]
    pub fn HAL_SetAnalogGyroDeadband(handle: HAL_GyroHandle, volts: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the gyro angle in degrees."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    #[doc = " @return the gyro angle in degrees"]
    pub fn HAL_GetAnalogGyroAngle(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the gyro rate in degrees/second."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    #[doc = " @return the gyro rate in degrees/second"]
    pub fn HAL_GetAnalogGyroRate(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro offset."]
    #[doc = ""]
    #[doc = " Can be used to not repeat a calibration but reconstruct the gyro object."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    #[doc = " @return the gryo offset"]
    pub fn HAL_GetAnalogGyroOffset(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro center."]
    #[doc = ""]
    #[doc = " Can be used to not repeat a calibration but reconstruct the gyro object."]
    #[doc = ""]
    #[doc = " @param handle the gyro handle"]
    #[doc = " @return the gyro center"]
    pub fn HAL_GetAnalogGyroCenter(handle: HAL_GyroHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Initializes the analog input port using the given port object."]
    #[doc = ""]
    #[doc = " @param portHandle Handle to the port to initialize."]
    #[doc = " @return           the created analog input handle"]
    pub fn HAL_InitializeAnalogInputPort(
        portHandle: HAL_PortHandle,
        status: *mut i32,
    ) -> HAL_AnalogInputHandle;
}
extern "C" {
    #[doc = " Frees an analog input port."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port."]
    pub fn HAL_FreeAnalogInputPort(analogPortHandle: HAL_AnalogInputHandle);
}
extern "C" {
    #[doc = " Checks that the analog module number is valid."]
    #[doc = ""]
    #[doc = " @param module The analog module number."]
    #[doc = " @return Analog module is valid and present"]
    pub fn HAL_CheckAnalogModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is value."]
    #[doc = " Verifies that the analog channel number is one of the legal channel numbers."]
    #[doc = " Channel numbers are 0-based."]
    #[doc = ""]
    #[doc = " @param channel The analog output channel number."]
    #[doc = " @return Analog channel is valid"]
    pub fn HAL_CheckAnalogInputChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Indicates the analog input is used by a simulated device."]
    #[doc = ""]
    #[doc = " @param handle the analog input handle"]
    #[doc = " @param device simulated device handle"]
    pub fn HAL_SetAnalogInputSimDevice(handle: HAL_AnalogInputHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Sets the sample rate."]
    #[doc = ""]
    #[doc = " This is a global setting for the Athena and effects all channels."]
    #[doc = ""]
    #[doc = " @param samplesPerSecond The number of samples per channel per second."]
    pub fn HAL_SetAnalogSampleRate(samplesPerSecond: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current sample rate."]
    #[doc = ""]
    #[doc = " This assumes one entry in the scan list."]
    #[doc = " This is a global setting for the Athena and effects all channels."]
    #[doc = ""]
    #[doc = " @return Sample rate."]
    pub fn HAL_GetAnalogSampleRate(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the number of averaging bits."]
    #[doc = ""]
    #[doc = " This sets the number of averaging bits. The actual number of averaged samples"]
    #[doc = " is 2**bits. Use averaging to improve the stability of your measurement at the"]
    #[doc = " expense of sampling rate. The averaging is done automatically in the FPGA."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to configure."]
    #[doc = " @param bits Number of bits to average."]
    pub fn HAL_SetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of averaging bits."]
    #[doc = ""]
    #[doc = " This gets the number of averaging bits from the FPGA. The actual number of"]
    #[doc = " averaged samples is 2**bits. The averaging is done automatically in the FPGA."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return Bits to average."]
    pub fn HAL_GetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the number of oversample bits."]
    #[doc = ""]
    #[doc = " This sets the number of oversample bits. The actual number of oversampled"]
    #[doc = " values is 2**bits. Use oversampling to improve the resolution of your"]
    #[doc = " measurements at the expense of sampling rate. The oversampling is done"]
    #[doc = " automatically in the FPGA."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @param bits Number of bits to oversample."]
    pub fn HAL_SetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of oversample bits."]
    #[doc = ""]
    #[doc = " This gets the number of oversample bits from the FPGA. The actual number of"]
    #[doc = " oversampled values is 2**bits. The oversampling is done automatically in the"]
    #[doc = " FPGA."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return Bits to oversample."]
    pub fn HAL_GetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a sample straight from the channel on this module."]
    #[doc = ""]
    #[doc = " The sample is a 12-bit value representing the 0V to 5V range of the A/D"]
    #[doc = " converter in the module. The units are in A/D converter codes.  Use"]
    #[doc = " GetVoltage() to get the analog value in calibrated units."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return A sample straight from the channel on this module."]
    pub fn HAL_GetAnalogValue(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets a sample from the output of the oversample and average engine for the"]
    #[doc = " channel."]
    #[doc = ""]
    #[doc = " The sample is 12-bit + the value configured in SetOversampleBits()."]
    #[doc = " The value configured in SetAverageBits() will cause this value to be averaged"]
    #[doc = " 2**bits number of samples. This is not a sliding window.  The sample will not"]
    #[doc = " change until 2**(OversamplBits + AverageBits) samples have been acquired from"]
    #[doc = " the module on this channel. Use GetAverageVoltage() to get the analog value"]
    #[doc = " in calibrated units."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return A sample from the oversample and average engine for the channel."]
    pub fn HAL_GetAnalogAverageValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Converts a voltage to a raw value for a specified channel."]
    #[doc = ""]
    #[doc = " This process depends on the calibration of each channel, so the channel must"]
    #[doc = " be specified."]
    #[doc = ""]
    #[doc = " @todo This assumes raw values.  Oversampling not supported as is."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @param voltage The voltage to convert."]
    #[doc = " @return The raw value for the channel."]
    pub fn HAL_GetAnalogVoltsToValue(
        analogPortHandle: HAL_AnalogInputHandle,
        voltage: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled sample straight from the channel on this module."]
    #[doc = ""]
    #[doc = " The value is scaled to units of Volts using the calibrated scaling data from"]
    #[doc = " GetLSBWeight() and GetOffset()."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return A scaled sample straight from the channel on this module."]
    pub fn HAL_GetAnalogVoltage(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a scaled sample from the output of the oversample and average engine for"]
    #[doc = " the channel."]
    #[doc = ""]
    #[doc = " The value is scaled to units of Volts using the calibrated scaling data from"]
    #[doc = " GetLSBWeight() and GetOffset(). Using oversampling will cause this value to"]
    #[doc = " be higher resolution, but it will update more slowly. Using averaging will"]
    #[doc = " cause this value to be more stable, but it will update more slowly."]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return A scaled sample from the output of the oversample and average engine"]
    #[doc = " for the channel."]
    pub fn HAL_GetAnalogAverageVoltage(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the factory scaling least significant bit weight constant."]
    #[doc = " The least significant bit weight constant for the channel that was calibrated"]
    #[doc = " in manufacturing and stored in an eeprom in the module."]
    #[doc = ""]
    #[doc = " Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)"]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return Least significant bit weight."]
    pub fn HAL_GetAnalogLSBWeight(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " Gets the factory scaling offset constant."]
    #[doc = " The offset constant for the channel that was calibrated in manufacturing and"]
    #[doc = " stored in an eeprom in the module."]
    #[doc = ""]
    #[doc = " Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)"]
    #[doc = ""]
    #[doc = " @param analogPortHandle Handle to the analog port to use."]
    #[doc = " @return Offset constant."]
    pub fn HAL_GetAnalogOffset(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = "  Get the analog voltage from a raw value."]
    #[doc = ""]
    #[doc = " @param analogPortHandle  Handle to the analog port the values were read from."]
    #[doc = " @param rawValue          The raw analog value"]
    #[doc = " @return                  The voltage relating to the value"]
    pub fn HAL_GetAnalogValueToVolts(
        analogPortHandle: HAL_AnalogInputHandle,
        rawValue: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Initializes the analog output port using the given port object."]
    #[doc = ""]
    #[doc = " @param handle handle to the port"]
    #[doc = " @return       the created analog output handle"]
    pub fn HAL_InitializeAnalogOutputPort(
        portHandle: HAL_PortHandle,
        status: *mut i32,
    ) -> HAL_AnalogOutputHandle;
}
extern "C" {
    #[doc = " Frees an analog output port."]
    #[doc = ""]
    #[doc = " @param analogOutputHandle the analog output handle"]
    pub fn HAL_FreeAnalogOutputPort(analogOutputHandle: HAL_AnalogOutputHandle);
}
extern "C" {
    #[doc = " Sets an analog output value."]
    #[doc = ""]
    #[doc = " @param analogOutputHandle the analog output handle"]
    #[doc = " @param voltage            the voltage (0-5v) to output"]
    pub fn HAL_SetAnalogOutput(
        analogOutputHandle: HAL_AnalogOutputHandle,
        voltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current analog output value."]
    #[doc = ""]
    #[doc = " @param analogOutputHandle the analog output handle"]
    #[doc = " @return                   the current output voltage (0-5v)"]
    pub fn HAL_GetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle, status: *mut i32)
        -> f64;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is value."]
    #[doc = ""]
    #[doc = " Verifies that the analog channel number is one of the legal channel numbers."]
    #[doc = " Channel numbers are 0-based."]
    #[doc = ""]
    #[doc = " @return Analog channel is valid"]
    pub fn HAL_CheckAnalogOutputChannel(channel: i32) -> HAL_Bool;
}
pub mod HAL_AnalogTriggerType {
    #[doc = " The type of analog trigger to trigger on."]
    pub type Type = i32;
    pub const HAL_Trigger_kInWindow: Type = 0;
    pub const HAL_Trigger_kState: Type = 1;
    pub const HAL_Trigger_kRisingPulse: Type = 2;
    pub const HAL_Trigger_kFallingPulse: Type = 3;
}
extern "C" {
    #[doc = " Initializes an analog trigger."]
    #[doc = ""]
    #[doc = " @param portHandle the analog input to use for triggering"]
    #[doc = " @return           the created analog trigger handle"]
    pub fn HAL_InitializeAnalogTrigger(
        portHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Initializes an analog trigger with a Duty Cycle input"]
    #[doc = ""]
    pub fn HAL_InitializeAnalogTriggerDutyCycle(
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Frees an analog trigger."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    pub fn HAL_CleanAnalogTrigger(analogTriggerHandle: HAL_AnalogTriggerHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the raw ADC upper and lower limits of the analog trigger."]
    #[doc = ""]
    #[doc = " HAL_SetAnalogTriggerLimitsVoltage or HAL_SetAnalogTriggerLimitsDutyCycle"]
    #[doc = " is likely better in most cases."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @param lower               the lower ADC value"]
    #[doc = " @param upper               the upper ADC value"]
    pub fn HAL_SetAnalogTriggerLimitsRaw(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: i32,
        upper: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger."]
    #[doc = ""]
    #[doc = " The limits are given as floating point voltage values."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @param lower               the lower voltage value"]
    #[doc = " @param upper               the upper voltage value"]
    pub fn HAL_SetAnalogTriggerLimitsVoltage(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAnalogTriggerLimitsDutyCycle(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use the averaged vs. raw values."]
    #[doc = ""]
    #[doc = " If the value is true, then the averaged value is selected for the analog"]
    #[doc = " trigger, otherwise the immediate value is used."]
    #[doc = ""]
    #[doc = " This is not allowed to be used if filtered mode is set."]
    #[doc = " This is not allowed to be used with Duty Cycle based inputs."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @param useAveragedValue    true to use averaged values, false for raw"]
    pub fn HAL_SetAnalogTriggerAveraged(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useAveragedValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use a filtered value."]
    #[doc = ""]
    #[doc = " The analog trigger will operate with a 3 point average rejection filter. This"]
    #[doc = " is designed to help with 360 degree pot applications for the period where the"]
    #[doc = " pot crosses through zero."]
    #[doc = ""]
    #[doc = " This is not allowed to be used if averaged mode is set."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @param useFilteredValue    true to use filtered values, false for average or"]
    #[doc = " raw"]
    pub fn HAL_SetAnalogTriggerFiltered(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useFilteredValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Returns the InWindow output of the analog trigger."]
    #[doc = ""]
    #[doc = " True if the analog input is between the upper and lower limits."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @return                    the InWindow output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerInWindow(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the TriggerState output of the analog trigger."]
    #[doc = ""]
    #[doc = " True if above upper limit."]
    #[doc = " False if below lower limit."]
    #[doc = " If in Hysteresis, maintain previous state."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @return                    the TriggerState output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerTriggerState(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the state of the analog trigger output."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @param type                the type of trigger to trigger on"]
    #[doc = " @return                    the state of the analog trigger output"]
    pub fn HAL_GetAnalogTriggerOutput(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        type_: HAL_AnalogTriggerType::Type,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Get the FPGA index for the AnlogTrigger."]
    #[doc = ""]
    #[doc = " @param analogTriggerHandle the trigger handle"]
    #[doc = " @return the FPGA index"]
    pub fn HAL_GetAnalogTriggerFPGAIndex(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> i32;
}
#[doc = " Storage for CAN Stream Messages."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_CANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_HAL_CANStreamMessage() {
    assert_eq!(
        ::std::mem::size_of::<HAL_CANStreamMessage>(),
        20usize,
        concat!("Size of: ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_CANStreamMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_CANStreamMessage>())).messageID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(messageID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_CANStreamMessage>())).timeStamp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_CANStreamMessage>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_CANStreamMessage>())).dataSize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(dataSize)
        )
    );
}
extern "C" {
    #[doc = " Sends a CAN message."]
    #[doc = ""]
    #[doc = " @param messageID the CAN ID to send"]
    #[doc = " @param data      the data to send (0-8 bytes)"]
    #[doc = " @param dataSize  the size of the data to send (0-8 bytes)"]
    #[doc = " @param periodMs  the period to repeat the packet at. Use"]
    #[doc = " HAL_CAN_SEND_PERIOD_NO_REPEAT to not repeat."]
    pub fn HAL_CAN_SendMessage(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Receives a CAN message."]
    #[doc = ""]
    #[doc = " @param messageID     store for the received message ID"]
    #[doc = " @param messageIDMask the message ID mask to look for"]
    #[doc = " @param data          data output (8 bytes)"]
    #[doc = " @param dataSize      data length (0-8 bytes)"]
    #[doc = " @param timeStamp     the packet received timestamp (based off of"]
    #[doc = " CLOCK_MONOTONIC)"]
    pub fn HAL_CAN_ReceiveMessage(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Opens a CAN stream."]
    #[doc = ""]
    #[doc = " @param sessionHandle output for the session handle"]
    #[doc = " @param messageID     the message ID to read"]
    #[doc = " @param messageIDMask the mssage ID mask"]
    #[doc = " @param maxMessages   the maximum number of messages to stream"]
    pub fn HAL_CAN_OpenStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Closes a CAN stream."]
    #[doc = ""]
    #[doc = " @param sessionHandle the session to close"]
    pub fn HAL_CAN_CloseStreamSession(sessionHandle: u32);
}
extern "C" {
    #[doc = " Reads a CAN stream message."]
    #[doc = ""]
    #[doc = " @param sessionHandle  the session handle"]
    #[doc = " @param messages       array of messages"]
    #[doc = " @param messagesToRead the max number of messages to read"]
    #[doc = " @param messageRead    the number of messages actually read"]
    pub fn HAL_CAN_ReadStreamSession(
        sessionHandle: u32,
        messages: *mut HAL_CANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets CAN status information."]
    #[doc = ""]
    #[doc = " @param percentBusUtilization the bus utilization"]
    #[doc = " @param busOffCount           the number of bus off errors"]
    #[doc = " @param txFullCount           the number of tx full errors"]
    #[doc = " @param receiveErrorCount     the number of receive errors"]
    #[doc = " @param transmitErrorCount    the number of transmit errors"]
    pub fn HAL_CAN_GetCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
pub mod HAL_CANDeviceType {
    #[doc = " The CAN device type."]
    #[doc = ""]
    #[doc = " Teams should use HAL_CAN_Dev_kMiscellaneous"]
    pub type Type = i32;
    pub const HAL_CAN_Dev_kBroadcast: Type = 0;
    pub const HAL_CAN_Dev_kRobotController: Type = 1;
    pub const HAL_CAN_Dev_kMotorController: Type = 2;
    pub const HAL_CAN_Dev_kRelayController: Type = 3;
    pub const HAL_CAN_Dev_kGyroSensor: Type = 4;
    pub const HAL_CAN_Dev_kAccelerometer: Type = 5;
    pub const HAL_CAN_Dev_kUltrasonicSensor: Type = 6;
    pub const HAL_CAN_Dev_kGearToothSensor: Type = 7;
    pub const HAL_CAN_Dev_kPowerDistribution: Type = 8;
    pub const HAL_CAN_Dev_kPneumatics: Type = 9;
    pub const HAL_CAN_Dev_kMiscellaneous: Type = 10;
    pub const HAL_CAN_Dev_kFirmwareUpdate: Type = 31;
}
pub mod HAL_CANManufacturer {
    #[doc = " The CAN manufacturer ID."]
    #[doc = ""]
    #[doc = " Teams should use HAL_CAN_Man_kTeamUse."]
    pub type Type = i32;
    pub const HAL_CAN_Man_kBroadcast: Type = 0;
    pub const HAL_CAN_Man_kNI: Type = 1;
    pub const HAL_CAN_Man_kLM: Type = 2;
    pub const HAL_CAN_Man_kDEKA: Type = 3;
    pub const HAL_CAN_Man_kCTRE: Type = 4;
    pub const HAL_CAN_Man_kREV: Type = 5;
    pub const HAL_CAN_Man_kGrapple: Type = 6;
    pub const HAL_CAN_Man_kMS: Type = 7;
    pub const HAL_CAN_Man_kTeamUse: Type = 8;
    pub const HAL_CAN_Man_kKauaiLabs: Type = 9;
    pub const HAL_CAN_Man_kCopperforge: Type = 10;
    pub const HAL_CAN_Man_kPWF: Type = 11;
    pub const HAL_CAN_Man_kStudica: Type = 12;
}
extern "C" {
    #[doc = " Initializes a CAN device."]
    #[doc = ""]
    #[doc = " These follow the FIRST standard CAN layout. Link TBD"]
    #[doc = ""]
    #[doc = " @param manufacturer the can manufacturer"]
    #[doc = " @param deviceId     the device ID (0-63)"]
    #[doc = " @param deviceType   the device type"]
    #[doc = " @return             the created CAN handle"]
    pub fn HAL_InitializeCAN(
        manufacturer: HAL_CANManufacturer::Type,
        deviceId: i32,
        deviceType: HAL_CANDeviceType::Type,
        status: *mut i32,
    ) -> HAL_CANHandle;
}
extern "C" {
    #[doc = " Frees a CAN device"]
    #[doc = ""]
    #[doc = " @param handle the CAN handle"]
    pub fn HAL_CleanCAN(handle: HAL_CANHandle);
}
extern "C" {
    #[doc = " Writes a packet to the CAN device with a specific ID."]
    #[doc = ""]
    #[doc = " This ID is 10 bits."]
    #[doc = ""]
    #[doc = " @param handle the CAN handle"]
    #[doc = " @param data   the data to write (0-8 bytes)"]
    #[doc = " @param length the length of data (0-8)"]
    #[doc = " @param apiId  the ID to write (0-1023 bits)"]
    pub fn HAL_WriteCANPacket(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a repeating packet to the CAN device with a specific ID."]
    #[doc = ""]
    #[doc = " This ID is 10 bits."]
    #[doc = ""]
    #[doc = " The RoboRIO will automatically repeat the packet at the specified interval"]
    #[doc = ""]
    #[doc = " @param handle   the CAN handle"]
    #[doc = " @param data     the data to write (0-8 bytes)"]
    #[doc = " @param length   the length of data (0-8)"]
    #[doc = " @param apiId    the ID to write (0-1023)"]
    #[doc = " @param repeatMs the period to repeat in ms"]
    pub fn HAL_WriteCANPacketRepeating(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        repeatMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes an RTR frame of the specified length to the CAN device with the"]
    #[doc = " specific ID."]
    #[doc = ""]
    #[doc = " By spec, the length must be equal to the length sent by the other device,"]
    #[doc = " otherwise behavior is unspecified."]
    #[doc = ""]
    #[doc = " @param handle   the CAN handle"]
    #[doc = " @param length   the length of data to request (0-8)"]
    #[doc = " @param apiId    the ID to write (0-1023)"]
    pub fn HAL_WriteCANRTRFrame(handle: HAL_CANHandle, length: i32, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Stops a repeating packet with a specific ID."]
    #[doc = ""]
    #[doc = " This ID is 10 bits."]
    #[doc = ""]
    #[doc = " @param handle the CAN handle"]
    #[doc = " @param apiId  the ID to stop repeating (0-1023)"]
    pub fn HAL_StopCANPacketRepeating(handle: HAL_CANHandle, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a new CAN packet."]
    #[doc = ""]
    #[doc = " This will only return properly once per packet received. Multiple calls"]
    #[doc = " without receiving another packet will return an error code."]
    #[doc = ""]
    #[doc = " @param handle            the CAN handle"]
    #[doc = " @param apiId             the ID to read (0-1023)"]
    #[doc = " @param data              the packet data (8 bytes)"]
    #[doc = " @param length            the received length (0-8 bytes)"]
    #[doc = " @param receivedTimestamp the packet received timestamp (based off of"]
    #[doc = " CLOCK_MONOTONIC)"]
    pub fn HAL_ReadCANPacketNew(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will continuously return the last packet received,"]
    #[doc = " without accounting for packet age."]
    #[doc = ""]
    #[doc = " @param handle            the CAN handle"]
    #[doc = " @param apiId             the ID to read (0-1023)"]
    #[doc = " @param data              the packet data (8 bytes)"]
    #[doc = " @param length            the received length (0-8 bytes)"]
    #[doc = " @param receivedTimestamp the packet received timestamp (based off of"]
    #[doc = " CLOCK_MONOTONIC)"]
    pub fn HAL_ReadCANPacketLatest(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will return the last packet received until the"]
    #[doc = " packet is older then the requested timeout. Then it will return an error"]
    #[doc = " code."]
    #[doc = ""]
    #[doc = " @param handle            the CAN handle"]
    #[doc = " @param apiId             the ID to read (0-1023)"]
    #[doc = " @param data              the packet data (8 bytes)"]
    #[doc = " @param length            the received length (0-8 bytes)"]
    #[doc = " @param receivedTimestamp the packet received timestamp (based off of"]
    #[doc = " CLOCK_MONOTONIC)"]
    #[doc = " @param timeoutMs         the timeout time for the packet"]
    pub fn HAL_ReadCANPacketTimeout(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        timeoutMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes a compressor on the given PCM module."]
    #[doc = ""]
    #[doc = " @param module the module number"]
    #[doc = " @return       the created handle"]
    pub fn HAL_InitializeCompressor(module: i32, status: *mut i32) -> HAL_CompressorHandle;
}
extern "C" {
    #[doc = " Gets if a compressor module is valid."]
    #[doc = ""]
    #[doc = " @param module the module number"]
    #[doc = " @return       true if the module is valid, otherwise false"]
    pub fn HAL_CheckCompressorModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the compressor state (on or off)."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if the compressor is on, otherwise false"]
    pub fn HAL_GetCompressor(compressorHandle: HAL_CompressorHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the compressor to closed loop mode."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @param value            true for closed loop mode, false for off"]
    pub fn HAL_SetCompressorClosedLoopControl(
        compressorHandle: HAL_CompressorHandle,
        value: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets if the compressor is in closed loop mode."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if the compressor is in closed loop mode,"]
    #[doc = " otherwise false"]
    pub fn HAL_GetCompressorClosedLoopControl(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the compressor pressure switch state."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if the pressure switch is triggered, otherwise"]
    #[doc = " false"]
    pub fn HAL_GetCompressorPressureSwitch(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the compressor current."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 the compressor current in amps"]
    pub fn HAL_GetCompressorCurrent(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets if the compressor is faulted because of too high of current."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if falted, otherwise false"]
    pub fn HAL_GetCompressorCurrentTooHighFault(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if a sticky fauly is triggered because of too high of current."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if falted, otherwise false"]
    pub fn HAL_GetCompressorCurrentTooHighStickyFault(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if a sticky fauly is triggered because of a short."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if falted, otherwise false"]
    pub fn HAL_GetCompressorShortedStickyFault(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the compressor is faulted because of a short."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if shorted, otherwise false"]
    pub fn HAL_GetCompressorShortedFault(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if a sticky fault is triggered of the compressor not connected."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if falted, otherwise false"]
    pub fn HAL_GetCompressorNotConnectedStickyFault(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the compressor is not connected."]
    #[doc = ""]
    #[doc = " @param compressorHandle the compressor handle"]
    #[doc = " @return                 true if not connected, otherwise false"]
    pub fn HAL_GetCompressorNotConnectedFault(
        compressorHandle: HAL_CompressorHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the number of FPGA system clock ticks per microsecond."]
    #[doc = ""]
    #[doc = " @return the number of clock ticks per microsecond"]
    pub fn HAL_GetSystemClockTicksPerMicrosecond() -> i32;
}
pub mod HAL_Counter_Mode {
    #[doc = " The counter mode."]
    pub type Type = i32;
    pub const HAL_Counter_kTwoPulse: Type = 0;
    pub const HAL_Counter_kSemiperiod: Type = 1;
    pub const HAL_Counter_kPulseLength: Type = 2;
    pub const HAL_Counter_kExternalDirection: Type = 3;
}
extern "C" {
    #[doc = " Initializes a counter."]
    #[doc = ""]
    #[doc = " @param mode  the counter mode"]
    #[doc = " @param index the compressor index (output)"]
    #[doc = " @return      the created handle"]
    pub fn HAL_InitializeCounter(
        mode: HAL_Counter_Mode::Type,
        index: *mut i32,
        status: *mut i32,
    ) -> HAL_CounterHandle;
}
extern "C" {
    #[doc = " Frees a counter."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    pub fn HAL_FreeCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the average sample size of a counter."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @param size          the size of samples to average"]
    pub fn HAL_SetCounterAverageSize(counterHandle: HAL_CounterHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count up."]
    #[doc = ""]
    #[doc = " @param counterHandle       the counter handle"]
    #[doc = " @param digitalSourceHandle the digital source handle (either a"]
    #[doc = " HAL_AnalogTriggerHandle of a HAL_DigitalHandle)"]
    #[doc = " @param analogTriggerType   the analog trigger type if the source is an analog"]
    #[doc = " trigger"]
    pub fn HAL_SetCounterUpSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType::Type,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the up source to either detect rising edges or falling edges."]
    #[doc = ""]
    #[doc = " Note that both are allowed to be set true at the same time without issues."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @param risingEdge    true to trigger on rising"]
    #[doc = " @param fallingEdge   true to trigger on falling"]
    pub fn HAL_SetCounterUpSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the up counting source to the counter."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    pub fn HAL_ClearCounterUpSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count down."]
    #[doc = ""]
    #[doc = " @param counterHandle       the counter handle"]
    #[doc = " @param digitalSourceHandle the digital source handle (either a"]
    #[doc = " HAL_AnalogTriggerHandle of a HAL_DigitalHandle)"]
    #[doc = " @param analogTriggerType   the analog trigger type if the source is an analog"]
    #[doc = " trigger"]
    pub fn HAL_SetCounterDownSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType::Type,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the down source to either detect rising edges or falling edges."]
    #[doc = " Note that both are allowed to be set true at the same time without issues."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @param risingEdge    true to trigger on rising"]
    #[doc = " @param fallingEdge   true to trigger on falling"]
    pub fn HAL_SetCounterDownSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the down counting source to the counter."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    pub fn HAL_ClearCounterDownSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets standard up / down counting mode on this counter."]
    #[doc = ""]
    #[doc = " Up and down counts are sourced independently from two inputs."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    pub fn HAL_SetCounterUpDownMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets directional counting mode on this counter."]
    #[doc = ""]
    #[doc = " The direction is determined by the B input, with counting happening with the"]
    #[doc = " A input."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    pub fn HAL_SetCounterExternalDirectionMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets Semi-period mode on this counter."]
    #[doc = ""]
    #[doc = " The counter counts up based on the time the input is triggered. High or Low"]
    #[doc = " depends on the highSemiPeriod parameter."]
    #[doc = ""]
    #[doc = " @param counterHandle  the counter handle"]
    #[doc = " @param highSemiPeriod true for counting when the input is high, false for low"]
    pub fn HAL_SetCounterSemiPeriodMode(
        counterHandle: HAL_CounterHandle,
        highSemiPeriod: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the counter to count in up or down based on the length of the"]
    #[doc = " input pulse."]
    #[doc = ""]
    #[doc = " This mode is most useful for direction sensitive gear tooth sensors."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @param threshold The pulse length beyond which the counter counts the"]
    #[doc = " opposite direction (seconds)"]
    pub fn HAL_SetCounterPulseLengthMode(
        counterHandle: HAL_CounterHandle,
        threshold: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the Samples to Average which specifies the number of samples of the"]
    #[doc = " timer to average when calculating the period. Perform averaging to account"]
    #[doc = " for mechanical imperfections or as oversampling to increase resolution."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @return SamplesToAverage The number of samples being averaged (from 1 to 127)"]
    pub fn HAL_GetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the Samples to Average which specifies the number of samples of the"]
    #[doc = " timer to average when calculating the period. Perform averaging to account"]
    #[doc = " for mechanical imperfections or as oversampling to increase resolution."]
    #[doc = ""]
    #[doc = " @param counterHandle    the counter handle"]
    #[doc = " @param samplesToAverage The number of samples to average from 1 to 127"]
    pub fn HAL_SetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the Counter to zero."]
    #[doc = ""]
    #[doc = " Sets the counter value to zero. This does not effect the running state of the"]
    #[doc = " counter, just sets the current value to zero."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    pub fn HAL_ResetCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Reads the current counter value."]
    #[doc = ""]
    #[doc = " Reads the value at this instant. It may still be running, so it reflects the"]
    #[doc = " current value. Next time it is read, it might have a different value."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @return              the current counter value"]
    pub fn HAL_GetCounter(counterHandle: HAL_CounterHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetCounterPeriod(counterHandle: HAL_CounterHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\"."]
    #[doc = ""]
    #[doc = " Sets the maximum period where the device is considered moving. This value is"]
    #[doc = " used to determine the \"stopped\" state of the counter using the"]
    #[doc = " HAL_GetCounterStopped method."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @param maxPeriod     the maximum period where the counted device is"]
    #[doc = " considered moving in seconds"]
    pub fn HAL_SetCounterMaxPeriod(
        counterHandle: HAL_CounterHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Selects whether you want to continue updating the event timer output when"]
    #[doc = " there are no samples captured."]
    #[doc = ""]
    #[doc = " The output of the event timer has a buffer of periods that are averaged and"]
    #[doc = " posted to a register on the FPGA.  When the timer detects that the event"]
    #[doc = " source has stopped (based on the MaxPeriod) the buffer of samples to be"]
    #[doc = " averaged is emptied."]
    #[doc = ""]
    #[doc = " If you enable the update when empty, you will be"]
    #[doc = " notified of the stopped source and the event time will report 0 samples."]
    #[doc = ""]
    #[doc = " If you disable update when empty, the most recent average will remain on the"]
    #[doc = " output until a new sample is acquired."]
    #[doc = ""]
    #[doc = " You will never see 0 samples output (except when there have been no events"]
    #[doc = " since an FPGA reset) and you will likely not see the stopped bit become true"]
    #[doc = " (since it is updated at the end of an average and there are no samples to"]
    #[doc = " average)."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @param enabled       true to enable counter updating with no samples"]
    pub fn HAL_SetCounterUpdateWhenEmpty(
        counterHandle: HAL_CounterHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped."]
    #[doc = ""]
    #[doc = " Determine if the clocked input is stopped based on the MaxPeriod value set"]
    #[doc = " using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the"]
    #[doc = " device (and counter) are assumed to be stopped and it returns true."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @return              true if the most recent counter period exceeds the"]
    #[doc = " MaxPeriod value set by SetMaxPeriod"]
    pub fn HAL_GetCounterStopped(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the counter value changed."]
    #[doc = ""]
    #[doc = " @param counterHandle the counter handle"]
    #[doc = " @return              the last direction the counter value changed"]
    pub fn HAL_GetCounterDirection(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the Counter to return reversed sensing on the direction."]
    #[doc = ""]
    #[doc = " This allows counters to change the direction they are counting in the case of"]
    #[doc = " 1X and 2X quadrature encoding only. Any other counter mode isn't supported."]
    #[doc = ""]
    #[doc = " @param counterHandle    the counter handle"]
    #[doc = " @param reverseDirection true if the value counted should be negated."]
    pub fn HAL_SetCounterReverseDirection(
        counterHandle: HAL_CounterHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Creates a new instance of a digital port."]
    #[doc = ""]
    #[doc = " @param portHandle the port handle to create from"]
    #[doc = " @param input      true for input, false for output"]
    #[doc = " @return           the created digital handle"]
    pub fn HAL_InitializeDIOPort(
        portHandle: HAL_PortHandle,
        input: HAL_Bool,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Checks if a DIO channel is valid."]
    #[doc = ""]
    #[doc = " @param channel the channel number to check"]
    #[doc = " @return        true if the channel is correct, otherwise false"]
    pub fn HAL_CheckDIOChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_FreeDIOPort(dioPortHandle: HAL_DigitalHandle);
}
extern "C" {
    #[doc = " Indicates the DIO channel is used by a simulated device."]
    #[doc = ""]
    #[doc = " @param handle the DIO channel handle"]
    #[doc = " @param device simulated device handle"]
    pub fn HAL_SetDIOSimDevice(handle: HAL_DigitalHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Allocates a DO PWM Generator."]
    #[doc = ""]
    #[doc = " @return the allocated digital PWM handle"]
    pub fn HAL_AllocateDigitalPWM(status: *mut i32) -> HAL_DigitalPWMHandle;
}
extern "C" {
    #[doc = " Frees the resource associated with a DO PWM generator."]
    #[doc = ""]
    #[doc = " @param pwmGenerator the digital PWM handle"]
    pub fn HAL_FreeDigitalPWM(pwmGenerator: HAL_DigitalPWMHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Changes the frequency of the DO PWM generator."]
    #[doc = ""]
    #[doc = " The valid range is from 0.6 Hz to 19 kHz."]
    #[doc = ""]
    #[doc = "  The frequency resolution is logarithmic."]
    #[doc = ""]
    #[doc = " @param rate the frequency to output all digital output PWM signals"]
    pub fn HAL_SetDigitalPWMRate(rate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Configures the duty-cycle of the PWM generator."]
    #[doc = ""]
    #[doc = " @param pwmGenerator the digital PWM handle"]
    #[doc = " @param dutyCycle    the percent duty cycle to output [0..1]"]
    pub fn HAL_SetDigitalPWMDutyCycle(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures which DO channel the PWM signal is output on."]
    #[doc = ""]
    #[doc = " @param pwmGenerator the digital PWM handle"]
    #[doc = " @param channel      the channel to output on"]
    pub fn HAL_SetDigitalPWMOutputChannel(
        pwmGenerator: HAL_DigitalPWMHandle,
        channel: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a digital value to a DIO channel."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @param value         the state to set the digital channel (if it is"]
    #[doc = " configured as an output)"]
    pub fn HAL_SetDIO(dioPortHandle: HAL_DigitalHandle, value: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the direction of a DIO channel."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @param input         true to set input, false for output"]
    pub fn HAL_SetDIODirection(dioPortHandle: HAL_DigitalHandle, input: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a digital value from a DIO channel."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @return              the state of the specified channel"]
    pub fn HAL_GetDIO(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Reads the direction of a DIO channel."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @return              true for input, false for output"]
    pub fn HAL_GetDIODirection(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Generates a single digital pulse."]
    #[doc = ""]
    #[doc = " Write a pulse to the specified digital output channel. There can only be a"]
    #[doc = " single pulse going at any time."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @param pulseLength   the active length of the pulse (in seconds)"]
    pub fn HAL_Pulse(dioPortHandle: HAL_DigitalHandle, pulseLength: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Checks a DIO line to see if it is currently generating a pulse."]
    #[doc = ""]
    #[doc = " @return true if a pulse is in progress, otherwise false"]
    pub fn HAL_IsPulsing(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if any DIO line is currently generating a pulse."]
    #[doc = ""]
    #[doc = " @return true if a pulse on some line is in progress"]
    pub fn HAL_IsAnyPulsing(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Writes the filter index from the FPGA."]
    #[doc = ""]
    #[doc = " Set the filter index used to filter out short pulses."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @param filterIndex   the filter index (Must be in the range 0 - 3, where 0"]
    #[doc = " means \"none\" and 1 - 3 means filter # filterIndex - 1)"]
    pub fn HAL_SetFilterSelect(
        dioPortHandle: HAL_DigitalHandle,
        filterIndex: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads the filter index from the FPGA."]
    #[doc = ""]
    #[doc = " Gets the filter index used to filter out short pulses."]
    #[doc = ""]
    #[doc = " @param dioPortHandle the digital port handle"]
    #[doc = " @return filterIndex  the filter index (Must be in the range 0 - 3,"]
    #[doc = " where 0 means \"none\" and 1 - 3 means filter # filterIndex - 1)"]
    pub fn HAL_GetFilterSelect(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the filter period for the specified filter index."]
    #[doc = ""]
    #[doc = " Sets the filter period in FPGA cycles.  Even though there are 2 different"]
    #[doc = " filter index domains (MXP vs HDR), ignore that distinction for now since it"]
    #[doc = " compilicates the interface.  That can be changed later."]
    #[doc = ""]
    #[doc = " @param filterIndex the filter index, 0 - 2"]
    #[doc = " @param value       the number of cycles that the signal must not transition"]
    #[doc = " to be counted as a transition."]
    pub fn HAL_SetFilterPeriod(filterIndex: i32, value: i64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the filter period for the specified filter index."]
    #[doc = ""]
    #[doc = " Gets the filter period in FPGA cycles.  Even though there are 2 different"]
    #[doc = " filter index domains (MXP vs HDR), ignore that distinction for now since it"]
    #[doc = " compilicates the interface.  Set status to NiFpga_Status_SoftwareFault if the"]
    #[doc = " filter values miss-match."]
    #[doc = ""]
    #[doc = " @param filterIndex the filter index, 0 - 2"]
    #[doc = " @param value       the number of cycles that the signal must not transition"]
    #[doc = " to be counted as a transition."]
    pub fn HAL_GetFilterPeriod(filterIndex: i32, status: *mut i32) -> i64;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_ControlWord {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout_HAL_ControlWord() {
    assert_eq!(
        ::std::mem::size_of::<HAL_ControlWord>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_ControlWord))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_ControlWord>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_ControlWord))
    );
}
impl HAL_ControlWord {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        autonomous: u32,
        test: u32,
        eStop: u32,
        fmsAttached: u32,
        dsAttached: u32,
        control_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
            eStop as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
            fmsAttached as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
            dsAttached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
            control_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub mod HAL_AllianceStationID {
    pub type Type = i32;
    pub const kRed1: Type = 0;
    pub const kRed2: Type = 1;
    pub const kRed3: Type = 2;
    pub const kBlue1: Type = 3;
    pub const kBlue2: Type = 4;
    pub const kBlue3: Type = 5;
}
pub mod HAL_MatchType {
    pub type Type = i32;
    pub const HAL_kMatchType_none: Type = 0;
    pub const HAL_kMatchType_practice: Type = 1;
    pub const HAL_kMatchType_qualification: Type = 2;
    pub const HAL_kMatchType_elimination: Type = 3;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_JoystickAxes {
    pub count: i16,
    pub axes: [f32; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickAxes() {
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickAxes>(),
        52usize,
        concat!("Size of: ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickAxes>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickAxes>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickAxes>())).axes as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(axes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_JoystickPOVs {
    pub count: i16,
    pub povs: [i16; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickPOVs() {
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickPOVs>(),
        26usize,
        concat!("Size of: ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickPOVs>(),
        2usize,
        concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickPOVs>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickPOVs>())).povs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(povs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct HAL_JoystickButtons {
    pub buttons: u32,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickButtons() {
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickButtons>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickButtons>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickButtons>())).buttons as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickButtons>())).count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_JoystickDescriptor {
    pub isXbox: u8,
    pub type_: u8,
    pub name: [::std::os::raw::c_char; 256usize],
    pub axisCount: u8,
    pub axisTypes: [u8; 12usize],
    pub buttonCount: u8,
    pub povCount: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickDescriptor>(),
        273usize,
        concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).isXbox as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(isXbox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).type_ as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).name as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).axisCount as *const _ as usize
        },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).axisTypes as *const _ as usize
        },
        259usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisTypes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).buttonCount as *const _ as usize
        },
        271usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(buttonCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_JoystickDescriptor>())).povCount as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(povCount)
        )
    );
}
impl Default for HAL_JoystickDescriptor {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_MatchInfo {
    pub eventName: [::std::os::raw::c_char; 64usize],
    pub matchType: HAL_MatchType::Type,
    pub matchNumber: u16,
    pub replayNumber: u8,
    pub gameSpecificMessage: [u8; 64usize],
    pub gameSpecificMessageSize: u16,
}
#[test]
fn bindgen_test_layout_HAL_MatchInfo() {
    assert_eq!(
        ::std::mem::size_of::<HAL_MatchInfo>(),
        140usize,
        concat!("Size of: ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_MatchInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_MatchInfo>())).eventName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(eventName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_MatchInfo>())).matchType as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_MatchInfo>())).matchNumber as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_MatchInfo>())).replayNumber as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(replayNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_MatchInfo>())).gameSpecificMessage as *const _ as usize
        },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_MatchInfo>())).gameSpecificMessageSize as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessageSize)
        )
    );
}
impl Default for HAL_MatchInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " Sends an error to the driver station."]
    #[doc = ""]
    #[doc = " @param isError   true for error, false for warning"]
    #[doc = " @param errorCode the error code"]
    #[doc = " @param isLVCode  true for a LV error code, false for a standard error code"]
    #[doc = " @param details   the details of the error"]
    #[doc = " @param location  the file location of the errror"]
    #[doc = " @param callstack the callstack of the error"]
    #[doc = " @param printMsg  true to print the error message to stdout as well as to the"]
    #[doc = " DS"]
    pub fn HAL_SendError(
        isError: HAL_Bool,
        errorCode: i32,
        isLVCode: HAL_Bool,
        details: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        callStack: *const ::std::os::raw::c_char,
        printMsg: HAL_Bool,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the current control word of the driver station."]
    #[doc = ""]
    #[doc = " The control work contains the robot state."]
    #[doc = ""]
    #[doc = " @param controlWord the control word (out)"]
    #[doc = " @return            the error code, or 0 for success"]
    pub fn HAL_GetControlWord(controlWord: *mut HAL_ControlWord) -> i32;
}
extern "C" {
    #[doc = " Gets the current alliance station ID."]
    #[doc = ""]
    #[doc = " @param status the error code, or 0 for success"]
    #[doc = " @return       the alliance station ID"]
    pub fn HAL_GetAllianceStation(status: *mut i32) -> HAL_AllianceStationID::Type;
}
extern "C" {
    #[doc = " Gets the axes of a specific joystick."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @param axes        the axes values (output)"]
    #[doc = " @return            the error code, or 0 for success"]
    pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut HAL_JoystickAxes) -> i32;
}
extern "C" {
    #[doc = " Gets the POVs of a specific joystick."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @param povs        the POV values (output)"]
    #[doc = " @return            the error code, or 0 for success"]
    pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut HAL_JoystickPOVs) -> i32;
}
extern "C" {
    #[doc = " Gets the buttons of a specific joystick."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @param buttons     the button values (output)"]
    #[doc = " @return            the error code, or 0 for success"]
    pub fn HAL_GetJoystickButtons(joystickNum: i32, buttons: *mut HAL_JoystickButtons) -> i32;
}
extern "C" {
    #[doc = " Retrieves the Joystick Descriptor for particular slot."]
    #[doc = ""]
    #[doc = " @param desc [out] descriptor (data transfer object) to fill in.  desc is"]
    #[doc = " filled in regardless of success. In other words, if descriptor is not"]
    #[doc = " available, desc is filled in with default values matching the init-values in"]
    #[doc = " Java and C++ Driverstation for when caller requests a too-large joystick"]
    #[doc = " index."]
    #[doc = ""]
    #[doc = " @return error code reported from Network Comm back-end.  Zero is good,"]
    #[doc = " nonzero is bad."]
    pub fn HAL_GetJoystickDescriptor(joystickNum: i32, desc: *mut HAL_JoystickDescriptor) -> i32;
}
extern "C" {
    #[doc = " Gets is a specific joystick is considered to be an XBox controller."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @return            true if xbox, false otherwise"]
    pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the type of joystick connected."]
    #[doc = ""]
    #[doc = " This is device specific, and different depending on what system input type"]
    #[doc = " the joystick uses."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @return            the enumerated joystick type"]
    pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the name of a joystick."]
    #[doc = ""]
    #[doc = " The returned array must be freed with HAL_FreeJoystickName."]
    #[doc = ""]
    #[doc = " Will be null terminated."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @return            the joystick name"]
    pub fn HAL_GetJoystickName(joystickNum: i32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a joystick name received with HAL_GetJoystickName"]
    #[doc = ""]
    #[doc = " @param name the name storage"]
    pub fn HAL_FreeJoystickName(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the type of a specific joystick axis."]
    #[doc = ""]
    #[doc = " This is device specific, and different depending on what system input type"]
    #[doc = " the joystick uses."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick number"]
    #[doc = " @param axis        the axis number"]
    #[doc = " @return            the enumerated axis type"]
    pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
}
extern "C" {
    #[doc = " Set joystick outputs."]
    #[doc = ""]
    #[doc = " @param joystickNum the joystick numer"]
    #[doc = " @param outputs     bitmask of outputs, 1 for on 0 for off"]
    #[doc = " @param leftRumble  the left rumble value (0-FFFF)"]
    #[doc = " @param rightRumble the right rumble value (0-FFFF)"]
    #[doc = " @return            the error code, or 0 for success"]
    pub fn HAL_SetJoystickOutputs(
        joystickNum: i32,
        outputs: i64,
        leftRumble: i32,
        rightRumble: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the approximate match time."]
    #[doc = ""]
    #[doc = " The FMS does not send an official match time to the robots, but does send"]
    #[doc = " an approximate match time. The value will count down the time remaining in"]
    #[doc = " the current period (auto or teleop)."]
    #[doc = ""]
    #[doc = " Warning: This is not an official time (so it cannot be used to dispute ref"]
    #[doc = " calls or guarantee that a function will trigger before the match ends)."]
    #[doc = ""]
    #[doc = " The Practice Match function of the DS approximates the behaviour seen on"]
    #[doc = " the field."]
    #[doc = ""]
    #[doc = " @param status the error code, or 0 for success"]
    #[doc = " @return time remaining in current match period (auto or teleop)"]
    pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets info about a specific match."]
    #[doc = ""]
    #[doc = " @param info the match info (output)"]
    #[doc = " @return     the error code, or 0 for success"]
    pub fn HAL_GetMatchInfo(info: *mut HAL_MatchInfo) -> i32;
}
extern "C" {
    #[doc = " Releases the DS Mutex to allow proper shutdown of any threads that are"]
    #[doc = " waiting on it."]
    pub fn HAL_ReleaseDSMutex();
}
extern "C" {
    #[doc = " Checks if new control data has arrived since the last"]
    #[doc = " HAL_WaitForCachedControlData or HAL_IsNewControlData call. If new data has"]
    #[doc = " not arrived, waits for new data to arrive. Otherwise, returns immediately."]
    pub fn HAL_WaitForCachedControlData();
}
extern "C" {
    #[doc = " Checks if new control data has arrived since the last"]
    #[doc = " HAL_WaitForCachedControlData or HAL_IsNewControlData call. If new data has"]
    #[doc = " not arrived, waits for new data to arrive, or a timeout. Otherwise, returns"]
    #[doc = " immediately."]
    #[doc = ""]
    #[doc = " @param timeout timeout in seconds"]
    #[doc = " @return        true for new data, false for timeout"]
    pub fn HAL_WaitForCachedControlDataTimeout(timeout: f64) -> HAL_Bool;
}
extern "C" {
    #[doc = " Has a new control packet from the driver station arrived since the last"]
    #[doc = " time this function was called?"]
    #[doc = ""]
    #[doc = " @return true if the control data has been updated since the last call"]
    pub fn HAL_IsNewControlData() -> HAL_Bool;
}
extern "C" {
    #[doc = " Waits for the newest DS packet to arrive. Note that this is a blocking call."]
    pub fn HAL_WaitForDSData();
}
extern "C" {
    #[doc = " Waits for the newest DS packet to arrive. If timeout is <= 0, this will wait"]
    #[doc = " forever. Otherwise, it will wait until either a new packet, or the timeout"]
    #[doc = " time has passed."]
    #[doc = ""]
    #[doc = " @param timeout timeout in seconds"]
    #[doc = " @return        true for new data, false for timeout"]
    pub fn HAL_WaitForDSDataTimeout(timeout: f64) -> HAL_Bool;
}
extern "C" {
    #[doc = " Initializes the driver station communication. This will properly"]
    #[doc = " handle multiple calls. However note that this CANNOT be called from a library"]
    #[doc = " that interfaces with LabVIEW."]
    pub fn HAL_InitializeDriverStation();
}
extern "C" {
    #[doc = " Sets the program starting flag in the DS."]
    #[doc = ""]
    #[doc = " This is what changes the DS to showing robot code ready."]
    pub fn HAL_ObserveUserProgramStarting();
}
extern "C" {
    #[doc = " Sets the disabled flag in the DS."]
    #[doc = ""]
    #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
    #[doc = " state request. Ensure this get called about every 50ms, or the robot will be"]
    #[doc = " disabled by the DS."]
    pub fn HAL_ObserveUserProgramDisabled();
}
extern "C" {
    #[doc = " Sets the autonomous enabled flag in the DS."]
    #[doc = ""]
    #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
    #[doc = " state request. Ensure this get called about every 50ms, or the robot will be"]
    #[doc = " disabled by the DS."]
    pub fn HAL_ObserveUserProgramAutonomous();
}
extern "C" {
    #[doc = " Sets the teleoperated enabled flag in the DS."]
    #[doc = ""]
    #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
    #[doc = " state request. Ensure this get called about every 50ms, or the robot will be"]
    #[doc = " disabled by the DS."]
    pub fn HAL_ObserveUserProgramTeleop();
}
extern "C" {
    #[doc = " Sets the test mode flag in the DS."]
    #[doc = ""]
    #[doc = " This is used for the DS to ensure the robot is properly responding to its"]
    #[doc = " state request. Ensure this get called about every 50ms, or the robot will be"]
    #[doc = " disabled by the DS."]
    pub fn HAL_ObserveUserProgramTest();
}
pub mod HAL_EncoderIndexingType {
    #[doc = " The type of index pulse for the encoder."]
    pub type Type = i32;
    pub const HAL_kResetWhileHigh: Type = 0;
    pub const HAL_kResetWhileLow: Type = 1;
    pub const HAL_kResetOnFallingEdge: Type = 2;
    pub const HAL_kResetOnRisingEdge: Type = 3;
}
pub mod HAL_EncoderEncodingType {
    #[doc = " The encoding scaling of the encoder."]
    pub type Type = i32;
    pub const HAL_Encoder_k1X: Type = 0;
    pub const HAL_Encoder_k2X: Type = 1;
    pub const HAL_Encoder_k4X: Type = 2;
}
extern "C" {
    #[doc = " Initializes an encoder."]
    #[doc = ""]
    #[doc = " @param digitalSourceHandleA the A source (either a HAL_DigitalHandle or a"]
    #[doc = " HAL_AnalogTriggerHandle)"]
    #[doc = " @param analogTriggerTypeA   the analog trigger type of the A source if it is"]
    #[doc = " an analog trigger"]
    #[doc = " @param digitalSourceHandleB the B source (either a HAL_DigitalHandle or a"]
    #[doc = " HAL_AnalogTriggerHandle)"]
    #[doc = " @param analogTriggerTypeB   the analog trigger type of the B source if it is"]
    #[doc = " an analog trigger"]
    #[doc = " @param reverseDirection     true to reverse the counting direction from"]
    #[doc = " standard, otherwise false"]
    #[doc = " @param encodingType         the encoding type"]
    #[doc = "@return                     the created encoder handle"]
    pub fn HAL_InitializeEncoder(
        digitalSourceHandleA: HAL_Handle,
        analogTriggerTypeA: HAL_AnalogTriggerType::Type,
        digitalSourceHandleB: HAL_Handle,
        analogTriggerTypeB: HAL_AnalogTriggerType::Type,
        reverseDirection: HAL_Bool,
        encodingType: HAL_EncoderEncodingType::Type,
        status: *mut i32,
    ) -> HAL_EncoderHandle;
}
extern "C" {
    #[doc = " Frees an encoder."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    pub fn HAL_FreeEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Indicates the encoder is used by a simulated device."]
    #[doc = ""]
    #[doc = " @param handle the encoder handle"]
    #[doc = " @param device simulated device handle"]
    pub fn HAL_SetEncoderSimDevice(handle: HAL_EncoderHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Gets the current counts of the encoder after encoding type scaling."]
    #[doc = ""]
    #[doc = " This is scaled by the value passed duing initialization to encodingType."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return the current scaled count"]
    pub fn HAL_GetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the raw counts of the encoder."]
    #[doc = ""]
    #[doc = " This is not scaled by any values."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the raw encoder count"]
    pub fn HAL_GetEncoderRaw(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the encoder scale value."]
    #[doc = ""]
    #[doc = " This is set by the value passed during initialization to encodingType."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the encoder scale value"]
    pub fn HAL_GetEncoderEncodingScale(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads the current encoder value."]
    #[doc = ""]
    #[doc = " Read the value at this instant. It may still be running, so it reflects the"]
    #[doc = " current value. Next time it is read, it might have a different value."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the current encoder value"]
    pub fn HAL_ResetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetEncoderPeriod(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\"."]
    #[doc = ""]
    #[doc = " Sets the maximum period where the device is considered moving. This value is"]
    #[doc = " used to determine the \"stopped\" state of the encoder using the"]
    #[doc = " HAL_GetEncoderStopped method."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @param maxPeriod     the maximum period where the counted device is"]
    #[doc = " considered moving in seconds"]
    pub fn HAL_SetEncoderMaxPeriod(
        encoderHandle: HAL_EncoderHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped."]
    #[doc = ""]
    #[doc = " Determines if the clocked input is stopped based on the MaxPeriod value set"]
    #[doc = " using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the"]
    #[doc = " device (and encoder) are assumed to be stopped and it returns true."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              true if the most recent encoder period exceeds the"]
    #[doc = " MaxPeriod value set by SetMaxPeriod"]
    pub fn HAL_GetEncoderStopped(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the encoder value changed."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the last direction the encoder value changed"]
    pub fn HAL_GetEncoderDirection(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the current distance traveled by the encoder."]
    #[doc = ""]
    #[doc = " This is the encoder count scaled by the distance per pulse set for the"]
    #[doc = " encoder."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the encoder distance (units are determined by the units"]
    #[doc = " passed to HAL_SetEncoderDistancePerPulse)"]
    pub fn HAL_GetEncoderDistance(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the current rate of the encoder."]
    #[doc = ""]
    #[doc = " This is the encoder period scaled by the distance per pulse set for the"]
    #[doc = " encoder."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the encoder rate (units are determined by the units"]
    #[doc = " passed to HAL_SetEncoderDistancePerPulse, time value is seconds)"]
    pub fn HAL_GetEncoderRate(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the minimum rate to be considered moving by the encoder."]
    #[doc = ""]
    #[doc = " Units need to match what is set by HAL_SetEncoderDistancePerPulse, with time"]
    #[doc = " as seconds."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @param minRate       the minimum rate to be considered moving (units are"]
    #[doc = " determined by the units passed to HAL_SetEncoderDistancePerPulse, time value"]
    #[doc = " is seconds)"]
    pub fn HAL_SetEncoderMinRate(encoderHandle: HAL_EncoderHandle, minRate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the distance traveled per encoder pulse. This is used as a scaling"]
    #[doc = " factor for the rate and distance calls."]
    #[doc = ""]
    #[doc = " @param encoderHandle    the encoder handle"]
    #[doc = " @param distancePerPulse the distance traveled per encoder pulse (units user"]
    #[doc = " defined)"]
    pub fn HAL_SetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        distancePerPulse: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if to reverse the direction of the encoder."]
    #[doc = ""]
    #[doc = " Note that this is not a toggle. It is an absolute set."]
    #[doc = ""]
    #[doc = " @param encoderHandle    the encoder handle"]
    #[doc = " @param reverseDirection true to reverse the direction, false to not."]
    pub fn HAL_SetEncoderReverseDirection(
        encoderHandle: HAL_EncoderHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the number of encoder samples to average when calculating encoder rate."]
    #[doc = ""]
    #[doc = " @param encoderHandle    the encoder handle"]
    #[doc = " @param samplesToAverage the number of samples to average"]
    pub fn HAL_SetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current samples to average value."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the current samples to average value"]
    pub fn HAL_GetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the source for an index pulse on the encoder."]
    #[doc = ""]
    #[doc = " The index pulse can be used to cause an encoder to reset based on an external"]
    #[doc = " input."]
    #[doc = ""]
    #[doc = " @param encoderHandle       the encoder handle"]
    #[doc = " @param digitalSourceHandle the index source handle (either a"]
    #[doc = " HAL_AnalogTriggerHandle of a HAL_DigitalHandle)"]
    #[doc = " @param analogTriggerType   the analog trigger type if the source is an analog"]
    #[doc = " trigger"]
    #[doc = " @param type                the index triggering type"]
    pub fn HAL_SetEncoderIndexSource(
        encoderHandle: HAL_EncoderHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType::Type,
        type_: HAL_EncoderIndexingType::Type,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the FPGA index of the encoder."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the FPGA index of the encoder"]
    pub fn HAL_GetEncoderFPGAIndex(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the decoding scale factor of the encoder."]
    #[doc = ""]
    #[doc = " This is used to perform the scaling from raw to type scaled values."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the scale value for the encoder"]
    pub fn HAL_GetEncoderDecodingScaleFactor(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the user set distance per pulse of the encoder."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the set distance per pulse"]
    pub fn HAL_GetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the encoding type of the encoder."]
    #[doc = ""]
    #[doc = " @param encoderHandle the encoder handle"]
    #[doc = " @return              the encoding type"]
    pub fn HAL_GetEncoderEncodingType(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> HAL_EncoderEncodingType::Type;
}
extern "C" {
    #[doc = " Reports a hardware usage to the HAL."]
    #[doc = ""]
    #[doc = " @param resource       the used resource"]
    #[doc = " @param instanceNumber the instance of the resource"]
    #[doc = " @param context        a user specified context index"]
    #[doc = " @param feature        a user specified feature string"]
    #[doc = " @return               the index of the added value in NetComm"]
    pub fn HAL_Report(
        resource: i32,
        instanceNumber: i32,
        context: i32,
        feature: *const ::std::os::raw::c_char,
    ) -> i64;
}
pub mod HALUsageReporting_tResourceType {
    pub type Type = i32;
    pub const Controller: Type = 0;
    pub const Module: Type = 1;
    pub const Language: Type = 2;
    pub const CANPlugin: Type = 3;
    pub const Accelerometer: Type = 4;
    pub const ADXL345: Type = 5;
    pub const AnalogChannel: Type = 6;
    pub const AnalogTrigger: Type = 7;
    pub const AnalogTriggerOutput: Type = 8;
    pub const CANJaguar: Type = 9;
    pub const Compressor: Type = 10;
    pub const Counter: Type = 11;
    pub const Dashboard: Type = 12;
    pub const DigitalInput: Type = 13;
    pub const DigitalOutput: Type = 14;
    pub const DriverStationCIO: Type = 15;
    pub const DriverStationEIO: Type = 16;
    pub const DriverStationLCD: Type = 17;
    pub const Encoder: Type = 18;
    pub const GearTooth: Type = 19;
    pub const Gyro: Type = 20;
    pub const I2C: Type = 21;
    pub const Framework: Type = 22;
    pub const Jaguar: Type = 23;
    pub const Joystick: Type = 24;
    pub const Kinect: Type = 25;
    pub const KinectStick: Type = 26;
    pub const PIDController: Type = 27;
    pub const Preferences: Type = 28;
    pub const PWM: Type = 29;
    pub const Relay: Type = 30;
    pub const RobotDrive: Type = 31;
    pub const SerialPort: Type = 32;
    pub const Servo: Type = 33;
    pub const Solenoid: Type = 34;
    pub const SPI: Type = 35;
    pub const Task: Type = 36;
    pub const Ultrasonic: Type = 37;
    pub const Victor: Type = 38;
    pub const Button: Type = 39;
    pub const Command: Type = 40;
    pub const AxisCamera: Type = 41;
    pub const PCVideoServer: Type = 42;
    pub const SmartDashboard: Type = 43;
    pub const Talon: Type = 44;
    pub const HiTechnicColorSensor: Type = 45;
    pub const HiTechnicAccel: Type = 46;
    pub const HiTechnicCompass: Type = 47;
    pub const SRF08: Type = 48;
    pub const AnalogOutput: Type = 49;
    pub const VictorSP: Type = 50;
    pub const PWMTalonSRX: Type = 51;
    pub const CANTalonSRX: Type = 52;
    pub const ADXL362: Type = 53;
    pub const ADXRS450: Type = 54;
    pub const RevSPARK: Type = 55;
    pub const MindsensorsSD540: Type = 56;
    pub const DigitalGlitchFilter: Type = 57;
    pub const ADIS16448: Type = 58;
    pub const PDP: Type = 59;
    pub const PCM: Type = 60;
    pub const PigeonIMU: Type = 61;
    pub const NidecBrushless: Type = 62;
    pub const CANifier: Type = 63;
    pub const TalonFX: Type = 64;
    pub const CTRE_future1: Type = 65;
    pub const CTRE_future2: Type = 66;
    pub const CTRE_future3: Type = 67;
    pub const CTRE_future4: Type = 68;
    pub const CTRE_future5: Type = 69;
    pub const CTRE_future6: Type = 70;
    pub const LinearFilter: Type = 71;
    pub const XboxController: Type = 72;
    pub const UsbCamera: Type = 73;
    pub const NavX: Type = 74;
    pub const Pixy: Type = 75;
    pub const Pixy2: Type = 76;
    pub const ScanseSweep: Type = 77;
    pub const Shuffleboard: Type = 78;
    pub const CAN: Type = 79;
    pub const DigilentDMC60: Type = 80;
    pub const PWMVictorSPX: Type = 81;
    pub const RevSparkMaxPWM: Type = 82;
    pub const RevSparkMaxCAN: Type = 83;
    pub const ADIS16470: Type = 84;
    pub const PIDController2: Type = 85;
    pub const ProfiledPIDController: Type = 86;
    pub const Kinematics: Type = 87;
    pub const Odometry: Type = 88;
    pub const Units: Type = 89;
    pub const TrapezoidProfile: Type = 90;
    pub const DutyCycle: Type = 91;
    pub const AddressableLEDs: Type = 92;
    pub const FusionVenom: Type = 93;
}
pub mod HALUsageReporting_tInstances {
    pub type Type = i32;
    pub const kLanguage_LabVIEW: Type = 1;
    pub const kLanguage_CPlusPlus: Type = 2;
    pub const kLanguage_Java: Type = 3;
    pub const kLanguage_Python: Type = 4;
    pub const kLanguage_DotNet: Type = 5;
    pub const kCANPlugin_BlackJagBridge: Type = 1;
    pub const kCANPlugin_2CAN: Type = 2;
    pub const kFramework_Iterative: Type = 1;
    pub const kFramework_Simple: Type = 2;
    pub const kFramework_CommandControl: Type = 3;
    pub const kFramework_Timed: Type = 4;
    pub const kFramework_ROS: Type = 5;
    pub const kFramework_RobotBuilder: Type = 6;
    pub const kRobotDrive_ArcadeStandard: Type = 1;
    pub const kRobotDrive_ArcadeButtonSpin: Type = 2;
    pub const kRobotDrive_ArcadeRatioCurve: Type = 3;
    pub const kRobotDrive_Tank: Type = 4;
    pub const kRobotDrive_MecanumPolar: Type = 5;
    pub const kRobotDrive_MecanumCartesian: Type = 6;
    pub const kRobotDrive2_DifferentialArcade: Type = 7;
    pub const kRobotDrive2_DifferentialTank: Type = 8;
    pub const kRobotDrive2_DifferentialCurvature: Type = 9;
    pub const kRobotDrive2_MecanumCartesian: Type = 10;
    pub const kRobotDrive2_MecanumPolar: Type = 11;
    pub const kRobotDrive2_KilloughCartesian: Type = 12;
    pub const kRobotDrive2_KilloughPolar: Type = 13;
    pub const kDriverStationCIO_Analog: Type = 1;
    pub const kDriverStationCIO_DigitalIn: Type = 2;
    pub const kDriverStationCIO_DigitalOut: Type = 3;
    pub const kDriverStationEIO_Acceleration: Type = 1;
    pub const kDriverStationEIO_AnalogIn: Type = 2;
    pub const kDriverStationEIO_AnalogOut: Type = 3;
    pub const kDriverStationEIO_Button: Type = 4;
    pub const kDriverStationEIO_LED: Type = 5;
    pub const kDriverStationEIO_DigitalIn: Type = 6;
    pub const kDriverStationEIO_DigitalOut: Type = 7;
    pub const kDriverStationEIO_FixedDigitalOut: Type = 8;
    pub const kDriverStationEIO_PWM: Type = 9;
    pub const kDriverStationEIO_Encoder: Type = 10;
    pub const kDriverStationEIO_TouchSlider: Type = 11;
    pub const kADXL345_SPI: Type = 1;
    pub const kADXL345_I2C: Type = 2;
    pub const kCommand_Scheduler: Type = 1;
    pub const kSmartDashboard_Instance: Type = 1;
}
pub mod HAL_RuntimeType {
    #[doc = " @defgroup hal_capi WPILib HAL API"]
    #[doc = " Hardware Abstraction Layer to hardware or simulator"]
    #[doc = " @{"]
    pub type Type = i32;
    pub const HAL_Athena: Type = 0;
    pub const HAL_Mock: Type = 1;
}
extern "C" {
    #[doc = " Gets the error message for a specific status code."]
    #[doc = ""]
    #[doc = " @param code the status code"]
    #[doc = " @return     the error message for the code. This does not need to be freed."]
    pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the FPGA Version number."]
    #[doc = ""]
    #[doc = " For now, expect this to be competition year."]
    #[doc = ""]
    #[doc = " @return FPGA Version number."]
    pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Returns the FPGA Revision number."]
    #[doc = ""]
    #[doc = " The format of the revision is 3 numbers."]
    #[doc = " The 12 most significant bits are the Major Revision."]
    #[doc = " the next 8 bits are the Minor Revision."]
    #[doc = " The 12 least significant bits are the Build Number."]
    #[doc = ""]
    #[doc = " @return FPGA Revision number."]
    pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetRuntimeType() -> HAL_RuntimeType::Type;
}
extern "C" {
    #[doc = " Gets the state of the \"USER\" button on the roboRIO."]
    #[doc = ""]
    #[doc = " @return true if the button is currently pressed down"]
    pub fn HAL_GetFPGAButton(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system outputs are currently active"]
    #[doc = ""]
    #[doc = " @return true if the system outputs are active, false if disabled"]
    pub fn HAL_GetSystemActive(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system is in a browned out state."]
    #[doc = ""]
    #[doc = " @return true if the system is in a low voltage brown out, false otherwise"]
    pub fn HAL_GetBrownedOut(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel."]
    #[doc = ""]
    #[doc = " The created handle does not need to be freed."]
    #[doc = ""]
    #[doc = " @param channel the channel number"]
    #[doc = " @return        the created port"]
    pub fn HAL_GetPort(channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel and module."]
    #[doc = ""]
    #[doc = " This is expected to be used for PCMs, as the roboRIO does not work with"]
    #[doc = " modules anymore."]
    #[doc = ""]
    #[doc = " The created handle does not need to be freed."]
    #[doc = ""]
    #[doc = " @param module  the module number"]
    #[doc = " @param channel the channel number"]
    #[doc = " @return        the created port"]
    pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Reads the microsecond-resolution timer on the FPGA."]
    #[doc = ""]
    #[doc = " @return The current time in microseconds according to the FPGA (since FPGA"]
    #[doc = " reset)."]
    pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time."]
    #[doc = ""]
    #[doc = " Note: This is making the assumption that the timestamp being converted is"]
    #[doc = " always in the past.  If you call this with a future timestamp, it probably"]
    #[doc = " will make it in the past.  If you wait over 70 minutes between capturing the"]
    #[doc = " bottom 32 bits of the timestamp and expanding it, you will be off by"]
    #[doc = " multiples of 1<<32 microseconds."]
    #[doc = ""]
    #[doc = " @return The current time in microseconds according to the FPGA (since FPGA"]
    #[doc = " reset) as a 64 bit number."]
    pub fn HAL_ExpandFPGATime(unexpanded_lower: u32, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Call this to start up HAL. This is required for robot programs."]
    #[doc = ""]
    #[doc = " This must be called before any other HAL functions. Failure to do so will"]
    #[doc = " result in undefined behavior, and likely segmentation faults. This means that"]
    #[doc = " any statically initialized variables in a program MUST call this function in"]
    #[doc = " their constructors if they want to use other HAL calls."]
    #[doc = ""]
    #[doc = " The common parameters are 500 for timeout and 0 for mode."]
    #[doc = ""]
    #[doc = " This function is safe to call from any thread, and as many times as you wish."]
    #[doc = " It internally guards from any reentrancy."]
    #[doc = ""]
    #[doc = " The applicable modes are:"]
    #[doc = "   0: Try to kill an existing HAL from another program, if not successful,"]
    #[doc = " error."]
    #[doc = "   1: Force kill a HAL from another program."]
    #[doc = "   2: Just warn if another hal exists and cannot be killed. Will likely result"]
    #[doc = " in undefined behavior."]
    #[doc = ""]
    #[doc = " @param timeout the initialization timeout (ms)"]
    #[doc = " @param mode    the initialization mode (see remarks)"]
    #[doc = " @return        true if initialization was successful, otherwise false."]
    pub fn HAL_Initialize(timeout: i32, mode: i32) -> HAL_Bool;
}
pub mod HAL_I2CPort {
    #[doc = " @defgroup hal_i2c I2C Functions"]
    #[doc = " @ingroup hal_capi"]
    #[doc = " @{"]
    pub type Type = i32;
    pub const HAL_I2C_kInvalid: Type = -1;
    pub const HAL_I2C_kOnboard: Type = 0;
    pub const HAL_I2C_kMXP: Type = 1;
}
extern "C" {
    #[doc = " Initializes the I2C port."]
    #[doc = ""]
    #[doc = " Opens the port if necessary and saves the handle."]
    #[doc = " If opening the MXP port, also sets up the channel functions appropriately."]
    #[doc = ""]
    #[doc = " @param port The port to open, 0 for the on-board, 1 for the MXP."]
    pub fn HAL_InitializeI2C(port: HAL_I2CPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Generic I2C read/write transaction."]
    #[doc = ""]
    #[doc = " This is a lower-level interface to the I2C hardware giving you more control"]
    #[doc = " over each transaction."]
    #[doc = ""]
    #[doc = " @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    #[doc = " @param dataToSend Buffer of data to send as part of the transaction."]
    #[doc = " @param sendSize Number of bytes to send as part of the transaction."]
    #[doc = " @param dataReceived Buffer to read data into."]
    #[doc = " @param receiveSize Number of bytes to read from the device."]
    #[doc = " @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_TransactionI2C(
        port: HAL_I2CPort::Type,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
        dataReceived: *mut u8,
        receiveSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device."]
    #[doc = ""]
    #[doc = " Writes a single byte to a register on a device and wait until the"]
    #[doc = "   transaction is complete."]
    #[doc = ""]
    #[doc = " @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    #[doc = " @param registerAddress The address of the register on the device to be"]
    #[doc = " written."]
    #[doc = " @param data The byte to write to the register on the device."]
    #[doc = " @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_WriteI2C(
        port: HAL_I2CPort::Type,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a read transaction with the device."]
    #[doc = ""]
    #[doc = " Reads bytes from a device."]
    #[doc = " Most I2C devices will auto-increment the register pointer internally allowing"]
    #[doc = "   you to read consecutive registers on a device in a single transaction."]
    #[doc = ""]
    #[doc = " @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    #[doc = " @param registerAddress The register to read first in the transaction."]
    #[doc = " @param count The number of bytes to read in the transaction."]
    #[doc = " @param buffer A pointer to the array of bytes to store the data read from the"]
    #[doc = " device."]
    #[doc = " @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_ReadI2C(
        port: HAL_I2CPort::Type,
        deviceAddress: i32,
        buffer: *mut u8,
        count: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Closes an I2C port"]
    #[doc = ""]
    #[doc = " @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    pub fn HAL_CloseI2C(port: HAL_I2CPort::Type);
}
pub type HAL_InterruptHandlerFunction = ::std::option::Option<
    unsafe extern "C" fn(interruptAssertedMask: u32, param: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " Initializes an interrupt."]
    #[doc = ""]
    #[doc = " @param watcher true for synchronous interrupts, false for asynchronous"]
    #[doc = " @return        the created interrupt handle"]
    pub fn HAL_InitializeInterrupts(watcher: HAL_Bool, status: *mut i32) -> HAL_InterruptHandle;
}
extern "C" {
    #[doc = " Frees an interrupt."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @return                the param passed to the interrupt, or nullptr if one"]
    #[doc = " wasn't passed."]
    pub fn HAL_CleanInterrupts(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " In synchronous mode, waits for the defined interrupt to occur."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @param timeout        timeout in seconds"]
    #[doc = " @param ignorePrevious if true, ignore interrupts that happened before"]
    #[doc = " waitForInterrupt was called"]
    #[doc = " @return               the mask of interrupts that fired"]
    pub fn HAL_WaitForInterrupt(
        interruptHandle: HAL_InterruptHandle,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Enables interrupts to occur on this input."]
    #[doc = ""]
    #[doc = " Interrupts are disabled when the RequestInterrupt call is made. This gives"]
    #[doc = " time to do the setup of the other options before starting to field"]
    #[doc = " interrupts."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    pub fn HAL_EnableInterrupts(interruptHandle: HAL_InterruptHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Disables interrupts without without deallocating structures."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    pub fn HAL_DisableInterrupts(interruptHandle: HAL_InterruptHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Returns the timestamp for the rising interrupt that occurred most recently."]
    #[doc = ""]
    #[doc = " This is in the same time domain as HAL_GetFPGATime().  It only contains the"]
    #[doc = " bottom 32 bits of the timestamp.  If your robot has been running for over 1"]
    #[doc = " hour, you will need to fill in the upper 32 bits yourself."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @return                timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptRisingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the falling interrupt that occurred most recently."]
    #[doc = ""]
    #[doc = " This is in the same time domain as HAL_GetFPGATime().  It only contains the"]
    #[doc = " bottom 32 bits of the timestamp.  If your robot has been running for over 1"]
    #[doc = " hour, you will need to fill in the upper 32 bits yourself."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @return                timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptFallingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Requests interrupts on a specific digital source."]
    #[doc = ""]
    #[doc = " @param interruptHandle     the interrupt handle"]
    #[doc = " @param digitalSourceHandle the digital source handle (either a"]
    #[doc = " HAL_AnalogTriggerHandle of a HAL_DigitalHandle)"]
    #[doc = " @param analogTriggerType   the trigger type if the source is an AnalogTrigger"]
    pub fn HAL_RequestInterrupts(
        interruptHandle: HAL_InterruptHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType::Type,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Attaches an asynchronous interrupt handler to the interrupt."]
    #[doc = ""]
    #[doc = " This interrupt gets called directly on the FPGA interrupt thread, so will"]
    #[doc = " block other interrupts while running."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @param handler         the handler function for the interrupt to call"]
    #[doc = " @param param           a parameter to be passed to the handler"]
    pub fn HAL_AttachInterruptHandler(
        interruptHandle: HAL_InterruptHandle,
        handler: HAL_InterruptHandlerFunction,
        param: *mut ::std::os::raw::c_void,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Attaches an asynchronous interrupt handler to the interrupt."]
    #[doc = ""]
    #[doc = " This interrupt gets called on a thread specific to the interrupt, so will not"]
    #[doc = " block other interrupts."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @param handler         the handler function for the interrupt to call"]
    #[doc = " @param param           a parameter to be passed to the handler"]
    pub fn HAL_AttachInterruptHandlerThreaded(
        interruptHandle: HAL_InterruptHandle,
        handler: HAL_InterruptHandlerFunction,
        param: *mut ::std::os::raw::c_void,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the edges to trigger the interrupt on."]
    #[doc = ""]
    #[doc = " Note that both edges triggered is a valid configuration."]
    #[doc = ""]
    #[doc = " @param interruptHandle the interrupt handle"]
    #[doc = " @param risingEdge      true for triggering on rising edge"]
    #[doc = " @param fallingEdge     true for triggering on falling edge"]
    pub fn HAL_SetInterruptUpSourceEdge(
        interruptHandle: HAL_InterruptHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets up the system to run the provided main loop in the main thread (e.g."]
    #[doc = " the thread in which main() starts execution) and run the robot code in a"]
    #[doc = " separate thread."]
    #[doc = ""]
    #[doc = " Normally the robot code runs in the main thread, but some GUI systems"]
    #[doc = " require the GUI be run in the main thread."]
    #[doc = ""]
    #[doc = " To be effective, this function must be called before the robot code starts"]
    #[doc = " the main loop (e.g. by frc::StartRobot())."]
    #[doc = ""]
    #[doc = " @param param parameter data to pass to mainFunc and exitFunc"]
    #[doc = " @param mainFunc the function to be run when HAL_RunMain() is called."]
    #[doc = " @param exitFunc the function to be run when HAL_ExitMain() is called."]
    pub fn HAL_SetMain(
        param: *mut ::std::os::raw::c_void,
        mainFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        exitFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Returns true if HAL_SetMain() has been called."]
    #[doc = ""]
    #[doc = " @return True if HAL_SetMain() has been called, false otherwise."]
    pub fn HAL_HasMain() -> HAL_Bool;
}
extern "C" {
    #[doc = " Runs the main function provided to HAL_SetMain()."]
    #[doc = ""]
    #[doc = " If HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()"]
    #[doc = " is called."]
    pub fn HAL_RunMain();
}
extern "C" {
    #[doc = " Causes HAL_RunMain() to exit."]
    #[doc = ""]
    #[doc = " If HAL_SetMain() has been called, this calls the exit function provided"]
    #[doc = " to that function."]
    pub fn HAL_ExitMain();
}
extern "C" {
    #[doc = " Initializes a notifier."]
    #[doc = ""]
    #[doc = " A notifier is an FPGA controller timer that triggers at requested intervals"]
    #[doc = " based on the FPGA time. This can be used to make precise control loops."]
    #[doc = ""]
    #[doc = " @return the created notifier"]
    pub fn HAL_InitializeNotifier(status: *mut i32) -> HAL_NotifierHandle;
}
extern "C" {
    #[doc = " Sets the name of a notifier."]
    #[doc = ""]
    #[doc = " @param notifierHandle the notifier handle"]
    #[doc = " @param name name"]
    pub fn HAL_SetNotifierName(
        notifierHandle: HAL_NotifierHandle,
        name: *const ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops a notifier from running."]
    #[doc = ""]
    #[doc = " This will cause any call into HAL_WaitForNotifierAlarm to return."]
    #[doc = ""]
    #[doc = " @param notifierHandle the notifier handle"]
    pub fn HAL_StopNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Cleans a notifier."]
    #[doc = ""]
    #[doc = " Note this also stops a notifier if it is already running."]
    #[doc = ""]
    #[doc = " @param notifierHandle the notifier handle"]
    pub fn HAL_CleanNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Updates the trigger time for a notifier."]
    #[doc = ""]
    #[doc = " Note that this time is an absolute time relative to HAL_GetFPGATime()"]
    #[doc = ""]
    #[doc = " @param notifierHandle the notifier handle"]
    #[doc = " @param triggerTime    the updated trigger time"]
    pub fn HAL_UpdateNotifierAlarm(
        notifierHandle: HAL_NotifierHandle,
        triggerTime: u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Cancels the next notifier alarm."]
    #[doc = ""]
    #[doc = " This does not cause HAL_WaitForNotifierAlarm to return."]
    #[doc = ""]
    #[doc = " @param notifierHandle the notifier handle"]
    pub fn HAL_CancelNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Waits for the next alarm for the specific notifier."]
    #[doc = ""]
    #[doc = " This is a blocking call until either the time elapses or HAL_StopNotifier"]
    #[doc = " gets called."]
    #[doc = ""]
    #[doc = " @param notifierHandle the notifier handle"]
    #[doc = " @return               the FPGA time the notifier returned"]
    pub fn HAL_WaitForNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Initializes a Power Distribution Panel."]
    #[doc = ""]
    #[doc = " @param  module the module number to initialize"]
    #[doc = " @return the created PDP"]
    pub fn HAL_InitializePDP(module: i32, status: *mut i32) -> HAL_PDPHandle;
}
extern "C" {
    #[doc = " Cleans a PDP module."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    pub fn HAL_CleanPDP(handle: HAL_PDPHandle);
}
extern "C" {
    #[doc = " Checks if a PDP channel is valid."]
    #[doc = ""]
    #[doc = " @param channel the channel to check"]
    #[doc = " @return        true if the channel is valid, otherwise false"]
    pub fn HAL_CheckPDPChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if a PDP module is valid."]
    #[doc = ""]
    #[doc = " @param channel the module to check"]
    #[doc = " @return        true if the module is valid, otherwise false"]
    pub fn HAL_CheckPDPModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the temperature of the PDP."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    #[doc = " @return       the module temperature (celsius)"]
    pub fn HAL_GetPDPTemperature(handle: HAL_PDPHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the PDP input voltage."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    #[doc = " @return       the input voltage (volts)"]
    pub fn HAL_GetPDPVoltage(handle: HAL_PDPHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the current of a specific PDP channel."]
    #[doc = ""]
    #[doc = " @param module  the module"]
    #[doc = " @param channel the channel"]
    #[doc = " @return        the channel current (amps)"]
    pub fn HAL_GetPDPChannelCurrent(handle: HAL_PDPHandle, channel: i32, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the current of all 16 channels on the PDP."]
    #[doc = ""]
    #[doc = " The array must be large enough to hold all channels."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    #[doc = " @param current the currents (output)"]
    pub fn HAL_GetPDPAllChannelCurrents(
        handle: HAL_PDPHandle,
        currents: *mut f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the total current of the PDP."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    #[doc = " @return       the total current (amps)"]
    pub fn HAL_GetPDPTotalCurrent(handle: HAL_PDPHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the total power of the PDP."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    #[doc = " @return       the total power (watts)"]
    pub fn HAL_GetPDPTotalPower(handle: HAL_PDPHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the total energy of the PDP."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    #[doc = " @return       the total energy (joules)"]
    pub fn HAL_GetPDPTotalEnergy(handle: HAL_PDPHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Resets the PDP accumulated energy."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    pub fn HAL_ResetPDPTotalEnergy(handle: HAL_PDPHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Clears any PDP sticky faults."]
    #[doc = ""]
    #[doc = " @param handle the module handle"]
    pub fn HAL_ClearPDPStickyFaults(handle: HAL_PDPHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Initializes a PWM port."]
    #[doc = ""]
    #[doc = " @param portHandle the port to initialize"]
    #[doc = " @return           the created pwm handle"]
    pub fn HAL_InitializePWMPort(portHandle: HAL_PortHandle, status: *mut i32)
        -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Frees a PWM port."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the pwm handle"]
    pub fn HAL_FreePWMPort(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Checks if a pwm channel is valid."]
    #[doc = ""]
    #[doc = " @param channel the channel to check"]
    #[doc = " @return        true if the channel is valid, otherwise false"]
    pub fn HAL_CheckPWMChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the configuration settings for the PWM channel."]
    #[doc = ""]
    #[doc = " All values are in milliseconds."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle  the PWM handle"]
    #[doc = " @param maxPwm         the maximum PWM value"]
    #[doc = " @param deadbandMaxPwm the high range of the center deadband"]
    #[doc = " @param centerPwm      the center PWM value"]
    #[doc = " @param deadbandMinPwm the low range of the center deadband"]
    #[doc = " @param minPwm         the minimum PWM value"]
    pub fn HAL_SetPWMConfig(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: f64,
        deadbandMaxPwm: f64,
        centerPwm: f64,
        deadbandMinPwm: f64,
        minPwm: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the raw configuration settings for the PWM channel."]
    #[doc = ""]
    #[doc = " We recommend using HAL_SetPWMConfig() instead, as those values are properly"]
    #[doc = " scaled. Usually used for values grabbed by HAL_GetPWMConfigRaw()."]
    #[doc = ""]
    #[doc = " Values are in raw FPGA units."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle  the PWM handle"]
    #[doc = " @param maxPwm         the maximum PWM value"]
    #[doc = " @param deadbandMaxPwm the high range of the center deadband"]
    #[doc = " @param centerPwm      the center PWM value"]
    #[doc = " @param deadbandMinPwm the low range of the center deadband"]
    #[doc = " @param minPwm         the minimum PWM value"]
    pub fn HAL_SetPWMConfigRaw(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: i32,
        deadbandMaxPwm: i32,
        centerPwm: i32,
        deadbandMinPwm: i32,
        minPwm: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the raw pwm configuration settings for the PWM channel."]
    #[doc = ""]
    #[doc = " Values are in raw FPGA units. These units have the potential to change for"]
    #[doc = " any FPGA release."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle  the PWM handle"]
    #[doc = " @param maxPwm         the maximum PWM value"]
    #[doc = " @param deadbandMaxPwm the high range of the center deadband"]
    #[doc = " @param centerPwm      the center PWM value"]
    #[doc = " @param deadbandMinPwm the low range of the center deadband"]
    #[doc = " @param minPwm         the minimum PWM value"]
    pub fn HAL_GetPWMConfigRaw(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: *mut i32,
        deadbandMaxPwm: *mut i32,
        centerPwm: *mut i32,
        deadbandMinPwm: *mut i32,
        minPwm: *mut i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if the FPGA should output the center value if the input value is within"]
    #[doc = " the deadband."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle     the PWM handle"]
    #[doc = " @param eliminateDeadband true to eliminate deadband, otherwise false"]
    pub fn HAL_SetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        eliminateDeadband: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current eliminate deadband value."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @return              true if set, otherwise false"]
    pub fn HAL_GetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired value."]
    #[doc = ""]
    #[doc = " The values are in raw FPGA units, and have the potential to change with any"]
    #[doc = " FPGA release."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @param value         the PWM value to set"]
    pub fn HAL_SetPWMRaw(pwmPortHandle: HAL_DigitalHandle, value: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired scaled value."]
    #[doc = ""]
    #[doc = " The values range from -1 to 1 and the period is controlled by the PWM Period"]
    #[doc = " and MinHigh registers."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @param value         the scaled PWM value to set"]
    pub fn HAL_SetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, speed: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired position value."]
    #[doc = ""]
    #[doc = " The values range from 0 to 1 and the period is controlled by the PWM Period"]
    #[doc = " and MinHigh registers."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @param value         the positional PWM value to set"]
    pub fn HAL_SetPWMPosition(pwmPortHandle: HAL_DigitalHandle, position: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to be disabled."]
    #[doc = ""]
    #[doc = " The channel is disabled until the next time it is set. Note this is different"]
    #[doc = " from just setting a 0 speed, as this will actively stop all signalling on the"]
    #[doc = " channel."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle."]
    pub fn HAL_SetPWMDisabled(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets a value from a PWM channel."]
    #[doc = ""]
    #[doc = " The values are in raw FPGA units, and have the potential to change with any"]
    #[doc = " FPGA release."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @return              the current raw PWM value"]
    pub fn HAL_GetPWMRaw(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled value from a PWM channel."]
    #[doc = ""]
    #[doc = " The values range from -1 to 1."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @return              the current speed PWM value"]
    pub fn HAL_GetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a position value from a PWM channel."]
    #[doc = ""]
    #[doc = " The values range from 0 to 1."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle"]
    #[doc = " @return              the current positional PWM value"]
    pub fn HAL_GetPWMPosition(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Forces a PWM signal to go to 0 temporarily."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle."]
    pub fn HAL_LatchPWMZero(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets how how often the PWM signal is squelched, thus scaling the period."]
    #[doc = ""]
    #[doc = " @param pwmPortHandle the PWM handle."]
    #[doc = " @param squelchMask   the 2-bit mask of outputs to squelch"]
    pub fn HAL_SetPWMPeriodScale(
        pwmPortHandle: HAL_DigitalHandle,
        squelchMask: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the loop timing of the PWM system."]
    #[doc = ""]
    #[doc = " @return the loop time"]
    pub fn HAL_GetPWMLoopTiming(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the pwm starting cycle time."]
    #[doc = ""]
    #[doc = " This time is relative to the FPGA time."]
    #[doc = ""]
    #[doc = " @return the pwm cycle start time"]
    pub fn HAL_GetPWMCycleStartTime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Gets the number of analog accumulators in the current system."]
    #[doc = ""]
    #[doc = " @return the number of analog accumulators"]
    pub fn HAL_GetNumAccumulators() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog triggers in the current system."]
    #[doc = ""]
    #[doc = " @return the number of analog triggers"]
    pub fn HAL_GetNumAnalogTriggers() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog inputs in the current system."]
    #[doc = ""]
    #[doc = " @return the number of analog inputs"]
    pub fn HAL_GetNumAnalogInputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog outputs in the current system."]
    #[doc = ""]
    #[doc = " @return the number of analog outputs"]
    pub fn HAL_GetNumAnalogOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog counters in the current system."]
    #[doc = ""]
    #[doc = " @return the number of counters"]
    pub fn HAL_GetNumCounters() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital headers in the current system."]
    #[doc = ""]
    #[doc = " @return the number of digital headers"]
    pub fn HAL_GetNumDigitalHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM headers in the current system."]
    #[doc = ""]
    #[doc = " @return the number of PWM headers"]
    pub fn HAL_GetNumPWMHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital channels in the current system."]
    #[doc = ""]
    #[doc = " @return the number of digital channels"]
    pub fn HAL_GetNumDigitalChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM channels in the current system."]
    #[doc = ""]
    #[doc = " @return the number of PWM channels"]
    pub fn HAL_GetNumPWMChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital IO PWM outputs in the current system."]
    #[doc = ""]
    #[doc = " @return the number of digital IO PWM outputs"]
    pub fn HAL_GetNumDigitalPWMOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of quadrature encoders in the current system."]
    #[doc = ""]
    #[doc = " @return the number of quadrature encoders"]
    pub fn HAL_GetNumEncoders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of interrupts in the current system."]
    #[doc = ""]
    #[doc = " @return the number of interrupts"]
    pub fn HAL_GetNumInterrupts() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay channels in the current system."]
    #[doc = ""]
    #[doc = " @return the number of relay channels"]
    pub fn HAL_GetNumRelayChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay headers in the current system."]
    #[doc = ""]
    #[doc = " @return the number of relay headers"]
    pub fn HAL_GetNumRelayHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PCM modules in the current system."]
    #[doc = ""]
    #[doc = " @return the number of PCM modules"]
    pub fn HAL_GetNumPCMModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of solenoid channels in the current system."]
    #[doc = ""]
    #[doc = " @return the number of solenoid channels"]
    pub fn HAL_GetNumSolenoidChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP modules in the current system."]
    #[doc = ""]
    #[doc = " @return the number of PDP modules"]
    pub fn HAL_GetNumPDPModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP channels in the current system."]
    #[doc = ""]
    #[doc = " @return the number of PDP channels"]
    pub fn HAL_GetNumPDPChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of duty cycle inputs in the current system."]
    #[doc = ""]
    #[doc = " @return the number of Duty Cycle inputs"]
    pub fn HAL_GetNumDutyCycles() -> i32;
}
extern "C" {
    #[doc = " Gets the number of addressable LED generators in the current system."]
    #[doc = ""]
    #[doc = " @return the number of Addressable LED generators"]
    pub fn HAL_GetNumAddressableLEDs() -> i32;
}
extern "C" {
    #[doc = " Gets the roboRIO input voltage."]
    #[doc = ""]
    #[doc = " @return the input voltage (volts)"]
    pub fn HAL_GetVinVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the roboRIO input current."]
    #[doc = ""]
    #[doc = " @return the input current (amps)"]
    pub fn HAL_GetVinCurrent(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail voltage."]
    #[doc = ""]
    #[doc = " @return the 6V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail current."]
    #[doc = ""]
    #[doc = " @return the 6V rail current (amps)"]
    pub fn HAL_GetUserCurrent6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 6V rail."]
    #[doc = ""]
    #[doc = " @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive6V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 6V rail."]
    #[doc = ""]
    #[doc = " @return the number of 6V fault counts"]
    pub fn HAL_GetUserCurrentFaults6V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the 5V rail voltage."]
    #[doc = ""]
    #[doc = " @return the 5V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 5V rail current."]
    #[doc = ""]
    #[doc = " @return the 5V rail current (amps)"]
    pub fn HAL_GetUserCurrent5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 5V rail."]
    #[doc = ""]
    #[doc = " @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive5V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 5V rail."]
    #[doc = ""]
    #[doc = " @return the number of 5V fault counts"]
    pub fn HAL_GetUserCurrentFaults5V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the 3V3 rail voltage."]
    #[doc = ""]
    #[doc = " @return the 3V3 rail voltage (volts)"]
    pub fn HAL_GetUserVoltage3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 3V3 rail current."]
    #[doc = ""]
    #[doc = " @return the 3V3 rail current (amps)"]
    pub fn HAL_GetUserCurrent3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 3V3 rail."]
    #[doc = ""]
    #[doc = " @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive3V3(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 3V3 rail."]
    #[doc = ""]
    #[doc = " @return the number of 3V3 fault counts"]
    pub fn HAL_GetUserCurrentFaults3V3(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Initializes a relay."]
    #[doc = ""]
    #[doc = " Note this call will only initialize either the forward or reverse port of the"]
    #[doc = " relay. If you need both, you will need to initialize 2 relays."]
    #[doc = ""]
    #[doc = " @param portHandle the port handle to initialize"]
    #[doc = " @param fwd        true for the forward port, false for the reverse port"]
    #[doc = " @return           the created relay handle"]
    pub fn HAL_InitializeRelayPort(
        portHandle: HAL_PortHandle,
        fwd: HAL_Bool,
        status: *mut i32,
    ) -> HAL_RelayHandle;
}
extern "C" {
    #[doc = " Frees a relay port."]
    #[doc = ""]
    #[doc = " @param relayPortHandle the relay handle"]
    pub fn HAL_FreeRelayPort(relayPortHandle: HAL_RelayHandle);
}
extern "C" {
    #[doc = " Checks if a relay channel is valid."]
    #[doc = ""]
    #[doc = " @param channel the channel to check"]
    #[doc = " @return        true if the channel is valid, otherwise false"]
    pub fn HAL_CheckRelayChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the state of a relay output."]
    #[doc = ""]
    #[doc = " @param relayPortHandle the relay handle"]
    #[doc = " @param on              true for on, false for off"]
    pub fn HAL_SetRelay(relayPortHandle: HAL_RelayHandle, on: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current state of the relay channel."]
    #[doc = ""]
    #[doc = " @param relayPortHandle the relay handle"]
    #[doc = " @return                true for on, false for off"]
    pub fn HAL_GetRelay(relayPortHandle: HAL_RelayHandle, status: *mut i32) -> HAL_Bool;
}
pub mod HAL_SPIPort {
    #[doc = " @defgroup hal_spi SPI Functions"]
    #[doc = " @ingroup hal_capi"]
    #[doc = " @{"]
    pub type Type = i32;
    pub const HAL_SPI_kInvalid: Type = -1;
    pub const HAL_SPI_kOnboardCS0: Type = 0;
    pub const HAL_SPI_kOnboardCS1: Type = 1;
    pub const HAL_SPI_kOnboardCS2: Type = 2;
    pub const HAL_SPI_kOnboardCS3: Type = 3;
    pub const HAL_SPI_kMXP: Type = 4;
}
extern "C" {
    #[doc = " Initializes the SPI port. Opens the port if necessary and saves the handle."]
    #[doc = ""]
    #[doc = " If opening the MXP port, also sets up the channel functions appropriately."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS3, 4 for MXP"]
    pub fn HAL_InitializeSPI(port: HAL_SPIPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Performs an SPI send/receive transaction."]
    #[doc = ""]
    #[doc = " This is a lower-level interface to the spi hardware giving you more control"]
    #[doc = " over each transaction."]
    #[doc = ""]
    #[doc = " @param port         The number of the port to use. 0-3 for Onboard CS0-CS2, 4"]
    #[doc = " for MXP"]
    #[doc = " @param dataToSend   Buffer of data to send as part of the transaction."]
    #[doc = " @param dataReceived Buffer to read data into."]
    #[doc = " @param size         Number of bytes to transfer. [0..7]"]
    #[doc = " @return             Number of bytes transferred, -1 for error"]
    pub fn HAL_TransactionSPI(
        port: HAL_SPIPort::Type,
        dataToSend: *const u8,
        dataReceived: *mut u8,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device."]
    #[doc = ""]
    #[doc = " Writes to a device and wait until the transaction is complete."]
    #[doc = ""]
    #[doc = " @param port      The number of the port to use. 0-3 for Onboard CS0-CS2, 4"]
    #[doc = " for MXP"]
    #[doc = " @param datToSend The data to write to the register on the device."]
    #[doc = " @param sendSize  The number of bytes to be written"]
    #[doc = " @return          The number of bytes written. -1 for an error"]
    pub fn HAL_WriteSPI(port: HAL_SPIPort::Type, dataToSend: *const u8, sendSize: i32) -> i32;
}
extern "C" {
    #[doc = " Executes a read from the device."]
    #[doc = ""]
    #[doc = " This method does not write any data out to the device."]
    #[doc = ""]
    #[doc = " Most spi devices will require a register address to be written before they"]
    #[doc = " begin returning data."]
    #[doc = ""]
    #[doc = " @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP"]
    #[doc = " @param buffer A pointer to the array of bytes to store the data read from the"]
    #[doc = " device."]
    #[doc = " @param count  The number of bytes to read in the transaction. [1..7]"]
    #[doc = " @return       Number of bytes read. -1 for error."]
    pub fn HAL_ReadSPI(port: HAL_SPIPort::Type, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes the SPI port."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    pub fn HAL_CloseSPI(port: HAL_SPIPort::Type);
}
extern "C" {
    #[doc = " Sets the clock speed for the SPI bus."]
    #[doc = ""]
    #[doc = " @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP"]
    #[doc = " @param speed The speed in Hz (0-1MHz)"]
    pub fn HAL_SetSPISpeed(port: HAL_SPIPort::Type, speed: i32);
}
extern "C" {
    #[doc = " Sets the SPI options."]
    #[doc = ""]
    #[doc = " @param port             The number of the port to use. 0-3 for Onboard"]
    #[doc = " CS0-CS2, 4 for MXP"]
    #[doc = " @param msbFirst         True to write the MSB first, False for LSB first"]
    #[doc = " @param sampleOnTrailing True to sample on the trailing edge, False to sample"]
    #[doc = " on the leading edge"]
    #[doc = " @param clkIdleHigh      True to set the clock to active low, False to set the"]
    #[doc = " clock active high"]
    pub fn HAL_SetSPIOpts(
        port: HAL_SPIPort::Type,
        msbFirst: HAL_Bool,
        sampleOnTrailing: HAL_Bool,
        clkIdleHigh: HAL_Bool,
    );
}
extern "C" {
    #[doc = " Sets the CS Active high for a SPI port."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    pub fn HAL_SetSPIChipSelectActiveHigh(port: HAL_SPIPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the CS Active low for a SPI port."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    pub fn HAL_SetSPIChipSelectActiveLow(port: HAL_SPIPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the stored handle for a SPI port."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    #[doc = " @return     The stored handle for the SPI port. 0 represents no stored"]
    #[doc = " handle."]
    pub fn HAL_GetSPIHandle(port: HAL_SPIPort::Type) -> i32;
}
extern "C" {
    #[doc = " Sets the stored handle for a SPI port."]
    #[doc = ""]
    #[doc = " @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP."]
    #[doc = " @param handle The value of the handle for the port."]
    pub fn HAL_SetSPIHandle(port: HAL_SPIPort::Type, handle: i32);
}
extern "C" {
    #[doc = " Initializes the SPI automatic accumulator."]
    #[doc = ""]
    #[doc = " @param port       The number of the port to use. 0-3 for Onboard CS0-CS2, 4"]
    #[doc = " for MXP."]
    #[doc = " @param bufferSize The accumulator buffer size."]
    pub fn HAL_InitSPIAuto(port: HAL_SPIPort::Type, bufferSize: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an SPI automatic accumulator."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP."]
    pub fn HAL_FreeSPIAuto(port: HAL_SPIPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the period for automatic SPI accumulation."]
    #[doc = ""]
    #[doc = " @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP."]
    #[doc = " @param period The accumlation period (seconds)."]
    pub fn HAL_StartSPIAutoRate(port: HAL_SPIPort::Type, period: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Starts the auto SPI accumulator on a specific trigger."]
    #[doc = ""]
    #[doc = " Note that triggering on both rising and falling edges is a valid"]
    #[doc = " configuration."]
    #[doc = ""]
    #[doc = " @param port                The number of the port to use. 0-3 for Onboard"]
    #[doc = " CS0-CS2, 4 for MXP."]
    #[doc = " @param digitalSourceHandle The trigger source to use (Either"]
    #[doc = " HAL_AnalogTriggerHandle or HAL_DigitalHandle)."]
    #[doc = " @param analogTriggerType   The analog trigger type, if the source is an"]
    #[doc = " analog trigger."]
    #[doc = " @param triggerRising       Trigger on the rising edge if true."]
    #[doc = " @param triggerFalling      Trigger on the falling edge if true."]
    pub fn HAL_StartSPIAutoTrigger(
        port: HAL_SPIPort::Type,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType::Type,
        triggerRising: HAL_Bool,
        triggerFalling: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops an automatic SPI accumlation."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP."]
    pub fn HAL_StopSPIAuto(port: HAL_SPIPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the data to be transmitted to the device to initiate a read."]
    #[doc = ""]
    #[doc = " @param port       The number of the port to use. 0-3 for Onboard CS0-CS2, 4"]
    #[doc = " for MXP."]
    #[doc = " @param dataToSend Pointer to the data to send (Gets copied for continue use,"]
    #[doc = " so no need to keep alive)."]
    #[doc = " @param dataSize   The length of the data to send."]
    #[doc = " @param zeroSize   The number of zeros to send after the data."]
    pub fn HAL_SetSPIAutoTransmitData(
        port: HAL_SPIPort::Type,
        dataToSend: *const u8,
        dataSize: i32,
        zeroSize: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Immediately forces an SPI read to happen."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP."]
    pub fn HAL_ForceSPIAutoRead(port: HAL_SPIPort::Type, status: *mut i32);
}
extern "C" {
    #[doc = " Reads data received by the SPI accumulator.  Each received data sequence"]
    #[doc = " consists of a timestamp followed by the received data bytes, one byte per"]
    #[doc = " word (in the least significant byte).  The length of each received data"]
    #[doc = " sequence is the same as the combined dataSize + zeroSize set in"]
    #[doc = " HAL_SetSPIAutoTransmitData."]
    #[doc = ""]
    #[doc = " @param port      The number of the port to use. 0-3 for Onboard CS0-CS2, 4"]
    #[doc = " for MXP."]
    #[doc = " @param buffer    The buffer to store the data into."]
    #[doc = " @param numToRead The number of words to read."]
    #[doc = " @param timeout   The read timeout (in seconds)."]
    #[doc = " @return          The number of words actually read."]
    pub fn HAL_ReadSPIAutoReceivedData(
        port: HAL_SPIPort::Type,
        buffer: *mut u32,
        numToRead: i32,
        timeout: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the count of how many SPI accumulations have been missed."]
    #[doc = ""]
    #[doc = " @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for"]
    #[doc = " MXP."]
    #[doc = " @return     The number of missed accumulations."]
    pub fn HAL_GetSPIAutoDroppedCount(port: HAL_SPIPort::Type, status: *mut i32) -> i32;
}
pub mod HAL_SerialPort {
    #[doc = " @defgroup hal_serialport Serial Port Functions"]
    #[doc = " @ingroup hal_capi"]
    #[doc = " @{"]
    pub type Type = i32;
    pub const Onboard: Type = 0;
    pub const MXP: Type = 1;
    pub const USB1: Type = 2;
    pub const USB2: Type = 3;
}
extern "C" {
    #[doc = " Initializes a serial port."]
    #[doc = ""]
    #[doc = " The channels are either the onboard RS232, the mxp uart, or 2 USB ports. The"]
    #[doc = " top port is USB1, the bottom port is USB2."]
    #[doc = ""]
    #[doc = " @param port the serial port to initialize"]
    pub fn HAL_InitializeSerialPort(
        port: HAL_SerialPort::Type,
        status: *mut i32,
    ) -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Initializes a serial port with a direct name."]
    #[doc = ""]
    #[doc = " This name is the /dev name for a specific port."]
    #[doc = " Note these are not always consistent between roboRIO reboots."]
    #[doc = ""]
    #[doc = " @param port     the serial port to initialize"]
    #[doc = " @param portName the dev port name"]
    pub fn HAL_InitializeSerialPortDirect(
        port: HAL_SerialPort::Type,
        portName: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Gets the raw serial port file descriptor from a handle."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @return       the raw port descriptor"]
    pub fn HAL_GetSerialFD(handle: HAL_SerialPortHandle, status: *mut i32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the baud rate of a serial port."]
    #[doc = ""]
    #[doc = " Any value between 0 and 0xFFFFFFFF may be used. Default is 9600."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param baud   the baud rate to set"]
    pub fn HAL_SetSerialBaudRate(handle: HAL_SerialPortHandle, baud: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of data bits on a serial port."]
    #[doc = ""]
    #[doc = " Defaults to 8."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param bits   the number of data bits (5-8)"]
    pub fn HAL_SetSerialDataBits(handle: HAL_SerialPortHandle, bits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of parity bits on a serial port."]
    #[doc = ""]
    #[doc = " Valid values are:"]
    #[doc = "   0: None (default)"]
    #[doc = "   1: Odd"]
    #[doc = "   2: Even"]
    #[doc = "   3: Mark - Means exists and always 1"]
    #[doc = "   4: Space - Means exists and always 0"]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param parity the parity bit mode (see remarks for valid values)"]
    pub fn HAL_SetSerialParity(handle: HAL_SerialPortHandle, parity: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of stop bits on a serial port."]
    #[doc = ""]
    #[doc = " Valid values are:"]
    #[doc = "   10: One stop bit (default)"]
    #[doc = "   15: One and a half stop bits"]
    #[doc = "   20: Two stop bits"]
    #[doc = ""]
    #[doc = " @param handle   the serial port handle"]
    #[doc = " @param stopBits the stop bit value (see remarks for valid values)"]
    pub fn HAL_SetSerialStopBits(handle: HAL_SerialPortHandle, stopBits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the write mode on a serial port."]
    #[doc = ""]
    #[doc = " Valid values are:"]
    #[doc = "   1: Flush on access"]
    #[doc = "   2: Flush when full (default)"]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param mode   the mode to set (see remarks for valid values)"]
    pub fn HAL_SetSerialWriteMode(handle: HAL_SerialPortHandle, mode: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the flow control mode of a serial port."]
    #[doc = ""]
    #[doc = " Valid values are:"]
    #[doc = "   0: None (default)"]
    #[doc = "   1: XON-XOFF"]
    #[doc = "   2: RTS-CTS"]
    #[doc = "   3: DTR-DSR"]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param flow   the mode to set (see remarks for valid values)"]
    pub fn HAL_SetSerialFlowControl(handle: HAL_SerialPortHandle, flow: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the minimum serial read timeout of a port."]
    #[doc = ""]
    #[doc = " @param handle  the serial port handle"]
    #[doc = " @param timeout the timeout in milliseconds"]
    pub fn HAL_SetSerialTimeout(handle: HAL_SerialPortHandle, timeout: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the termination character that terminates a read."]
    #[doc = ""]
    #[doc = " By default this is disabled."]
    #[doc = ""]
    #[doc = " @param handle     the serial port handle"]
    #[doc = " @param terminator the termination character to set"]
    pub fn HAL_EnableSerialTermination(
        handle: HAL_SerialPortHandle,
        terminator: ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables a termination character for reads."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    pub fn HAL_DisableSerialTermination(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the read buffer."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param size   the read buffer size"]
    pub fn HAL_SetSerialReadBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the write buffer."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param size   the write buffer size"]
    pub fn HAL_SetSerialWriteBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the number of bytes currently in the read buffer."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @return       the number of bytes in the read buffer"]
    pub fn HAL_GetSerialBytesReceived(handle: HAL_SerialPortHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads data from the serial port."]
    #[doc = ""]
    #[doc = " Will wait for either timeout (if set), the termination char (if set), or the"]
    #[doc = " count to be full. Whichever one comes first."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param count  the number of bytes maximum to read"]
    #[doc = " @return       the number of bytes actually read"]
    pub fn HAL_ReadSerial(
        handle: HAL_SerialPortHandle,
        buffer: *mut ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Writes data to the serial port."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    #[doc = " @param buffer the buffer to write"]
    #[doc = " @param count  the number of bytes to write from the buffer"]
    #[doc = " @return       the number of bytes actually written"]
    pub fn HAL_WriteSerial(
        handle: HAL_SerialPortHandle,
        buffer: *const ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Flushes the serial write buffer out to the port."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    pub fn HAL_FlushSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Clears the receive buffer of the serial port."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle"]
    pub fn HAL_ClearSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Closes a serial port."]
    #[doc = ""]
    #[doc = " @param handle the serial port handle to close"]
    pub fn HAL_CloseSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Initializes a solenoid port."]
    #[doc = ""]
    #[doc = " @param portHandle the port handle of the module and channel to initialize"]
    #[doc = " @return           the created solenoid handle"]
    pub fn HAL_InitializeSolenoidPort(
        portHandle: HAL_PortHandle,
        status: *mut i32,
    ) -> HAL_SolenoidHandle;
}
extern "C" {
    #[doc = " Frees a solenoid port."]
    #[doc = ""]
    #[doc = " @param solenoidPortHandle the solenoid handle"]
    pub fn HAL_FreeSolenoidPort(solenoidPortHandle: HAL_SolenoidHandle);
}
extern "C" {
    #[doc = " Checks if a solenoid module is in the valid range."]
    #[doc = ""]
    #[doc = " @param module the module number to check"]
    #[doc = " @return       true if the module number is valid, otherwise false"]
    pub fn HAL_CheckSolenoidModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if a solenoid channel is in the valid range."]
    #[doc = ""]
    #[doc = " @param channel the channel number to check"]
    #[doc = " @return       true if the channel number is valid, otherwise false"]
    pub fn HAL_CheckSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the current solenoid output value."]
    #[doc = ""]
    #[doc = " @param solenoidPortHandle the solenoid handle"]
    #[doc = " @return                   true if the solenoid is on, otherwise false"]
    pub fn HAL_GetSolenoid(solenoidPortHandle: HAL_SolenoidHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the status of all solenoids on a specific module."]
    #[doc = ""]
    #[doc = " @param module the module to check"]
    #[doc = " @return       bitmask of the channels, 1 for on 0 for off"]
    pub fn HAL_GetAllSolenoids(module: i32, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets a solenoid output value."]
    #[doc = ""]
    #[doc = " @param solenoidPortHandle the solenoid handle"]
    #[doc = " @param value              true for on, false for off"]
    pub fn HAL_SetSolenoid(
        solenoidPortHandle: HAL_SolenoidHandle,
        value: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets all channels on a specific module."]
    #[doc = ""]
    #[doc = " @param module the module to set the channels on"]
    #[doc = " @param state  bitmask of the channels to set, 1 for on 0 for off"]
    pub fn HAL_SetAllSolenoids(module: i32, state: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the channels blacklisted from being enabled on a module."]
    #[doc = ""]
    #[doc = " @param module the module to check"]
    #[doc = " @retur        bitmask of the blacklisted channels, 1 for true 0 for false"]
    pub fn HAL_GetPCMSolenoidBlackList(module: i32, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets if a specific module has an over or under voltage sticky fault."]
    #[doc = ""]
    #[doc = " @param module the module to check"]
    #[doc = " @return       true if a stick fault is set, otherwise false"]
    pub fn HAL_GetPCMSolenoidVoltageStickyFault(module: i32, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if a specific module has an over or under voltage fault."]
    #[doc = ""]
    #[doc = " @param module the module to check"]
    #[doc = " @return       true if faulted, otherwise false"]
    pub fn HAL_GetPCMSolenoidVoltageFault(module: i32, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Clears all faults on a module."]
    #[doc = ""]
    #[doc = " @param module the module to clear"]
    pub fn HAL_ClearAllPCMStickyFaults(module: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the one shot duration on a solenoid channel."]
    #[doc = ""]
    #[doc = " @param solenoidPortHandle the solenoid handle"]
    #[doc = " @param durMS              the one shot duration in ms"]
    pub fn HAL_SetOneShotDuration(
        solenoidPortHandle: HAL_SolenoidHandle,
        durMS: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Fires a single pulse on a solenoid channel."]
    #[doc = ""]
    #[doc = " The pulse is the duration set by HAL_SetOneShotDuration()."]
    #[doc = ""]
    #[doc = " @param solenoidPortHandle the solenoid handle"]
    pub fn HAL_FireOneShot(solenoidPortHandle: HAL_SolenoidHandle, status: *mut i32);
}
#[doc = " @defgroup hal_threads Threads Functions"]
#[doc = " @ingroup hal_capi"]
#[doc = " @{"]
pub type NativeThreadHandle = *const ::std::os::raw::c_void;
extern "C" {
    #[doc = " Gets the thread priority for the specified thread."]
    #[doc = ""]
    #[doc = " @param handle     Native handle pointer to the thread to get the priority for"]
    #[doc = " @param isRealTime Set to true if thread is realtime, otherwise false"]
    #[doc = " @param status     Error status variable. 0 on success"]
    #[doc = " @return           The current thread priority. Scaled 1-99, with 1 being"]
    #[doc = " highest."]
    pub fn HAL_GetThreadPriority(
        handle: NativeThreadHandle,
        isRealTime: *mut HAL_Bool,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the thread priority for the current thread."]
    #[doc = ""]
    #[doc = " @param handle     Native handle pointer to the thread to get the priority for"]
    #[doc = " @param isRealTime Set to true if thread is realtime, otherwise false"]
    #[doc = " @param status     Error status variable. 0 on success"]
    #[doc = " @return           The current thread priority. Scaled 1-99, with 1 being"]
    #[doc = " highest."]
    pub fn HAL_GetCurrentThreadPriority(isRealTime: *mut HAL_Bool, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the thread priority for the specified thread."]
    #[doc = ""]
    #[doc = " @param thread   Reference to the thread to set the priority of"]
    #[doc = " @param realTime Set to true to set a realtime priority, false for standard"]
    #[doc = " priority"]
    #[doc = " @param priority Priority to set the thread to. Scaled 1-99, with 1 being"]
    #[doc = " highest"]
    #[doc = " @param status   Error status variable. 0 on success"]
    #[doc = " @return         The success state of setting the priority"]
    pub fn HAL_SetThreadPriority(
        handle: NativeThreadHandle,
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the thread priority for the current thread."]
    #[doc = ""]
    #[doc = " @param thread   Reference to the thread to set the priority of"]
    #[doc = " @param realTime Set to true to set a realtime priority, false for standard"]
    #[doc = " priority"]
    #[doc = " @param priority Priority to set the thread to. Scaled 1-99, with 1 being"]
    #[doc = " highest"]
    #[doc = " @param status   Error status variable. 0 on success"]
    #[doc = " @return         The success state of setting the priority"]
    pub fn HAL_SetCurrentThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
pub mod HAL_Type {
    #[doc = " HAL data types."]
    pub type Type = u32;
    pub const HAL_UNASSIGNED: Type = 0;
    pub const HAL_BOOLEAN: Type = 1;
    pub const HAL_DOUBLE: Type = 2;
    pub const HAL_ENUM: Type = 4;
    pub const HAL_INT: Type = 8;
    pub const HAL_LONG: Type = 16;
}
#[doc = " HAL Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_Value {
    pub data: HAL_Value__bindgen_ty_1,
    pub type_: HAL_Type::Type,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HAL_Value__bindgen_ty_1 {
    pub v_boolean: HAL_Bool,
    pub v_enum: i32,
    pub v_int: i32,
    pub v_long: i64,
    pub v_double: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_Value__bindgen_ty_1>())).v_boolean as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_Value__bindgen_ty_1>())).v_enum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_enum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_Value__bindgen_ty_1>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_Value__bindgen_ty_1>())).v_long as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HAL_Value__bindgen_ty_1>())).v_double as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
}
impl Default for HAL_Value__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_HAL_Value() {
    assert_eq!(
        ::std::mem::size_of::<HAL_Value>(),
        16usize,
        concat!("Size of: ", stringify!(HAL_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_Value>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HAL_Value>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for HAL_Value {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
